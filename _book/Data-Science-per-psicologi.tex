% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
]{memoir}
\title{Data Science per psicologi}
\author{Corrado Caudek}
\date{2021-10-10}

\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
  \setmonofont[]{Inconsolata}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Data Science per psicologi},
  pdfauthor={Corrado Caudek},
  colorlinks=true,
  linkcolor={Maroon},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\chapterstyle{bianchi}

\usepackage{mathtools}
\usepackage[italian]{babel} 
\usepackage{booktabs}
\usepackage{hyperref}
\hypersetup{
  colorlinks=true
}
\usepackage[
  labelfont=bf, 
  font={small, it} 
]{caption} 
\usepackage{upquote} % print correct quotes in verbatim-environments
\usepackage[autostyle, italian=quotes]{csquotes}
\usepackage{empheq} 
\usepackage{xfrac}

\raggedbottom % allow variable (ragged) site heights
\frenchspacing
% \setlength\parskip{1.5pt plus 1pt minus 0.5pt}


\DeclareMathOperator{\Var}{Var} % Define variance operator
\DeclareMathOperator{\SD}{SD} % Define sd operator
\DeclareMathOperator{\Cov}{Cov} % Define covariance operator
\DeclareMathOperator{\Corr}{Corr} % Define correlation operator
\DeclareMathOperator{\Me}{Me} % Define mediane operator
\DeclareMathOperator{\Mo}{Mo} % Define mode operator
\DeclareMathOperator{\Bin}{Bin} % Define binomial operator
\DeclareMathOperator{\Bernoulli}{Bernoulli} % Define Bernoulli operator
\DeclareMathOperator{\Poi}{Poi} % Define Poisson operator
\DeclareMathOperator{\Uniform}{Uniform} % Define Uniform operator
\DeclareMathOperator{\Cauchy}{Cauchy} % Define Cauchy operator
\DeclareMathOperator{\elpd}{elpd} % Define elpd operator
\DeclareMathOperator{\lppd}{lppd} % Define lppd operator
\DeclareMathOperator{\LOO}{LOO} % Define LOO operator
\DeclareMathOperator{\B}{\mathscr{B}} % Define Bernoulli operator
\newcommand{\R}{\textsf{R}} % Define R programming language symbol
\newcommand{\E}{\mathbb{E}} % Define expected value operator
\newcommand{\Real}{\mathbb{R}} % Define real number operator
\newcommand{\Prob}{\mathscr{P}}
\DeclareMathOperator*{\argmin}{arg\,min} % thin space, limits on side in displays
\DeclareMathOperator*{\argmax}{arg\,max} % thin space, limits on side in displays

\usepackage{microtype}

\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{apalike}

\usepackage{amsthm}
\newtheorem{theorem}{Teorema}[chapter]
\newtheorem{lemma}{Lemma}[chapter]
\newtheorem{corollary}{Corollario}[chapter]
\newtheorem{proposition}{Proposizione}[chapter]
\newtheorem{conjecture}{Congettura}[chapter]
\theoremstyle{definition}
\newtheorem{definition}{Definizione}[chapter]
\theoremstyle{definition}
\newtheorem{example}{Esempio}[chapter]
\theoremstyle{definition}
\newtheorem{exercise}{Exercizio}[chapter]
\theoremstyle{definition}
\newtheorem{hypothesis}{Hypothesis}[chapter]
\theoremstyle{remark}
\newtheorem*{remark}{Osservazione}
\newtheorem*{solution}{Soluzione}
\begin{document}
\maketitle

{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{1}
\tableofcontents
}
\newpage

\vspace*{5cm}

\thispagestyle{empty}

\hypertarget{chapter-misurazione}{%
\chapter{La misurazione in psicologia}\label{chapter-misurazione}}

Introduco il problema della misurazione in psicologia parlando dell'intelligenza. In quanto psicologi, siamo abituati a pensare alla misurazione dell'intelligenza, ma anche le persone che non sono psicologi sono ben familiari con la misurazione dell'intelligenza: tra le misurazioni delle caratteristiche psicologiche, infatti, la misurazione dell'intelligenza è forse la più conosciuta.

I test di intelligenza consistono in una serie di problemi di carattere verbale, numerico o simbolico. Come ci si può aspettare, alcune persone riescono a risolvere correttamente un numero maggiore di problemi di altre. Possiamo contare il numero di risposte corrette e osservare le differenze individuali nei punteggi calcolati. Scopriamo in questo modo che le differenze individuali nell'abilità di risolvere tali problemi risultano sorprendentemente stabili nell'età adulta. Inoltre, diversi test di intelligenza tendono ad essere correlati positivamente: le persone che risolvono un maggior numero di problemi verbali, in media, tenderanno anche a risolvere correttamente un numero più grande di numerici e simbolici. Esiste quindi una notevole coerenza delle differenze osservate tra le persone, sia nel tempo sia considerando diverse procedure di test e valutazione.

Avendo stabilito che ci sono differenze individuali tra le persone, è possibile esaminare le associazioni tra i punteggi dei test di intelligenza e altre variabili. Possiamo indagare se le persone con punteggi più alti nei test di intelligenza, rispetto a persone che ottengono punteggi più bassi, hanno più successo sul lavoro; se guadagnano di più; se votano in modo diverso; o se hanno un'aspettativa di vita più alta. Possiamo esaminare le differenze nei punteggi dei test di intelligenza in funzione di variabili come il genere, il gruppo etnico-razziale o lo stato socio-economico. Possiamo fare ricerche sull'associazione tra i punteggi dei test di intelligenza e l'efficienza dell'elaborazione neuronale, i tempi di reazione o la quantità di materia grigia all'interno della scatola cranica. Tutte queste ricerche sono state condotte e gli psicologi hanno scoperto una vasta gamma di associazioni tra le misure dell'intelligenza e altre variabili. Alcune di queste associazioni sono grandi e stabili, altre sono piccole e difficili da replicare. In riferimento all'intelligenza, dunque, gli psicologi hanno condotto un enorme numero di ricerche ponendosi domande diverse. In quali condizioni si verificano determinati effetti? Quali variabili mediano o moderano le relazioni tra i punteggi dei test di intelligenza e altre variabili? Queste relazioni si mantengono stabili in diversi gruppi di persone? Le ricerche sull'intelligenza umana sono un campo in continuo sviluppo.

Tuttavia, tuttavia una domanda sorge spontanea: i test di intelligenza misurano davvero qualcosa e, in caso affermativo, che cos'è questo qualcosa? Infatti, dopo un secolo di teoria e ricerca sui punteggi dei test di intelligenza e, in generale, sui test psicologici, non sappiamo ancora con precisione cosa effettivamente questi test misurano.
Queste considerazioni relative ai test di intelligenza ci conducono dunque alla domanda che ha motivato le precedenti considerazioni: cosa significa misurare un attributo psicologico? Questa è una domanda a cui è difficile rispondere, una domanda a cui è dedicata un'intera area di ricerca, quella della teoria della misurazione psicologica.

Non possiamo qui entrare nel merito delle complessità formali della teoria della misurazione psicologica -- questo argomento verrà approfondito nei successivi insegnamenti sulla testistica psicologica. Ci limiteremo invece a presentare alcune nozioni di base su un tema centrale della teoria della misurazione psicologica: il tema delle scale delle misure psicologiche.

\hypertarget{le-scale-di-misura}{%
\section{Le scale di misura}\label{le-scale-di-misura}}

In generale possiamo dire che la teoria della misurazione si occupa dello studio delle relazioni esistenti tra due domini: il ``mondo fisico'' e il ``mondo psicologico''. Secondo la teoria della misurazione, la misurazione è un'attività rappresentativa, cioè è un processo di assegnazione di numeri in modo tale da preservare, all'interno del dominio numerico, le relazioni qualitative che sono state osservate nel mondo empirico. La teoria della misurazione ha lo scopo di specificare le condizioni necessarie per la costruzione di una rappresentazione adeguata delle relazioni empiriche all'interno di un sistema numerico. Da una prospettiva formale, le operazioni descritte dalla teoria della misurazione possono essere concettualizzate in termini di mappatura tra le relazioni esistenti all'interno di due insiemi (quello empirico e quello numerico). Il risultato di questa attività è chiamato ``scala di misurazione''.

Una famosa teoria delle scale di misura è stata proposta da \citet{stevens46}. Stevens ci fa notare che, in linea di principio, le variabili psicologiche sono in grado di rappresentare (preservare) con diversi gradi di accuratezza le relazioni qualitative che sono state osservate nei fenomeni psicologici. Secondo la teoria di Stevens, possiamo distinguere tra quattro scale di misura: le scale nominali (\emph{nominal scales}), ordinali (\emph{ordinal scales}), a intervalli (\emph{interval scales}), di rapporti (\emph{ratio scales}). Tali scale di misura consentono operazioni aritmetiche diverse, come indicato nella tabella successiva, in quanto ciasuna di esse è in grado di ``catturare'' soltanto alcune delle proprietà dei fenomeni psicologici che intende misurare.

\includegraphics[width=0.8\textwidth,height=\textheight]{images/misurazione_2.png}

\hypertarget{scala-nominale}{%
\subsection{Scala nominale}\label{scala-nominale}}

Il livello di misurazione più semplice è quello della scala nominale. Questa scala di misurazione corrisponde ad una tassonomia. I simoboli o numeri che costituiscono questa scala non sono altro che i nomi delle categorie che utilizziamo per classificare i fenomeni psicologici. In base alle misure fornite da una scala nominale, l'unica cosa che siamo in grado di dire a proposito di una caratteristica psicologica è se essa è uguale o no ad un'altra caratteristica psicologica.

La scala nominale raggruppa dunque i dati in categorie qualitative \emph{mutuamente esclusive} (cioè nessun dato si può collocare in più di una categoria).
Esiste la sola relazione di equivalenza tra le misure delle u.s., cioè
nella scala nominale gli elementi del campione appartenenti a classi
diverse sono differenti, mentre tutti quelli della stessa classe sono
tra loro equivalenti: \(x_i = x_j\) oppure \(x_i \neq x_j\).

L'unica operazione algebrica che possiamo compiere sulle modalità della scala nominale è quella di contare le u.s. che appartengono ad ogni modalità e contare il numero delle modalità (classi di equivalenza). Dunque la descrizione dei dati avviene tramite le frequenze assolute e le frequenze relative.

A partire da una scala nominale è possibile costruire altre scale nominali che sono equivalenti alla prima trasformando i valori della scala di partenza in modo tale
da cambiare i nomi delle modalità, ma lasciando però inalterata la suddivisione u.s. nelle medesime classi di equivalenza. Questo significa che prendendo una variabile misurata su scala nominale e cambiando i nomi delle sue categorie otteniamo una nuova variabile esattamente corrispondente alla prima.

\hypertarget{scala-ordinale}{%
\subsection{Scala ordinale}\label{scala-ordinale}}

La scala ordinale conserva la proprietà della scala nominale di classificare ciascuna u.s. all'interno di una e una sola categoria, ma alla relazione di equivalenza tra elementi di una stessa classe aggiunge la relazione di ordinamento tra le classi di equivalenza. Essendo basata su una relazione d'ordine, una scala ordinale descrive soltanto l'ordine di rango tra le modalità, ma non ci dà alcuna informazione su quanto una modalità sia più grande di un'altra. Non ci dice, per esempio, se la distanza tra le modalità \(a\) e \(b\) sia uguale, maggiore o minore della distanza tra le modalità \(b\) e \(c\).

\begin{example}
Un esempio classico di scala ordinale è quello della scala Mohs per la
determinazione della durezza dei minerali. Per stabilire la durezza dei
minerali si usa il criterio empirico della scalfittura. Vengono
stabiliti livelli di durezza crescente da 1 a 10 con riferimento a dieci
minerali: talco, gesso, calcite, fluorite, apatite, ortoclasio, quarzo,
topazio, corindone e diamante. Un minerale appartenente ad uno di questi
livelli se scalfisce quello di livello inferiore ed è scalfito da quello
di livello superiore.
\end{example}

\hypertarget{scala-ad-intervalli}{%
\subsection{Scala ad intervalli}\label{scala-ad-intervalli}}

La scala ad intervalli include le proprietà di quella nominale e di
quella ordinale, e in più consente di misurare le distanze tra le coppie
di u.s. nei termini di un intervallo costante, chiamato \emph{unità di
misura}, a cui viene attribuito il valore ``1''. La posizione dell'origine
della scala, cioè il punto zero, è scelta arbitrariamente, nel senso che
non indica l'assenza della quantità che si sta misurando. Avendo uno
zero arbitrario, questa scala di misura consente valori negativi. Lo
zero, infatti, \emph{non} viene attribuito all'u.s. in cui la proprietà
misurata risulta assente.

La scala a intervalli equivalenti ci consente di effettuare operazioni
algebriche basate sulla differenza tra i numeri associati ai diversi
punti della scala, operazioni algebriche non era possibile eseguire nel
caso di misure a livello di scala ordinale o nominale. Il limite della
scala ad intervalli è quello di non consentire il calcolo del rapporto
tra coppie di misure. Possiamo dire, per esempio, che la distanza tra
\(a\) e \(b\) è la metà della distanza tra \(c\) e \(d\). Oppure che la distanza
tra \(a\) e \(b\) è uguale alla distanza tra \(c\) e \(d\). Non possiamo dire,
però, che \(a\) possiede la proprietà misurata in quantità doppia rispetto
\(b\). Non possiamo cioè stabilire dei rapporti diretti tra le misure
ottenute. Solo per le \emph{differenze} tra le modalità sono dunque permesse
tutte le operazioni aritmetiche: le differenze possono essere tra loro
sommate, elevate a potenza oppure divise, determinando così le quantità
che stanno alla base della statistica inferenziale.

Nelle scale ad intervalli equivalenti, l'unità di misura è arbitraria,
ovvero può essere cambiata attraverso una dilatazione, operazione che
consiste nel moltiplicare tutti i valori della scala per una costante
positiva. Poiché l'aggiunta di una costante non altera le differenze tra
i valori della scala, è anche ammessa la traslazione, operazione che
consiste nel sommare una costante a tutti i valori della scala. Essendo
la scala invariate rispetto alla traslazione e alla dilatazione, le
trasformazioni ammissibili sono le \emph{trasformazioni lineari}:
\[y' = a + by, \quad b > 0.\]
L'aspetto che rimane invariante a seguito di una trasformazione lineare
è l'uguaglianza dei rapporti fra intervalli.

\begin{example}
Esempio di scala ad intervalli è la temperatura misurata in gradi
Celsius o Fahrenheit, ma non Kelvin. Come per la scala nominale, è
possibile stabilire se due modalità sono uguali o diverse: 30\(^\circ\)C
\(\neq\) 20\(^\circ\)C. Come per la scala ordinale è possibile mettere due
modalità in una relazione d'ordine: 30\(^\circ\)C \(>\) 20\(^\circ\)C. In
aggiunta ai casi precedenti, però, è possibile definire una unità di
misura per cui è possibile dire che tra 30\(^\circ\)C e 20\(^\circ\)C c'è
una differenza di 30\(^\circ\) - 20\(^\circ\) = 10\(^\circ\)C. I valori di
temperatura, oltre a poter essere ordinati secondo l'intensità del
fenomeno, godono della proprietà che le differenze tra loro sono
direttamente confrontabili e quantificabili.

Il limite della scala ad intervalli è quello di non consentire il
calcolo del rapporto tra coppie di misure. Ad esempio, una temperatura
di 80\(^\circ\)C non è il doppio di una di 40\(^\circ\)C. Se infatti
esprimiamo le stesse temperature nei termini della scala Fahrenheit,
allora i due valori non saranno in rapporto di 1 a 2 tra loro. Infatti,
20\(^\circ\)C = 68\(^\circ\)F e 40\(^\circ\)C = 104\(^\circ\)F. Questo significa
che la relazione ``il doppio di'' che avevamo individuato in precedenza si
applicava ai numeri della scala centigrada, ma non alla proprietà
misurata (cioè la temperatura). La decisione di che scala usare
(Centigrada vs.~Fahrenheit) è arbitraria. Ma questa arbitrarietà non
deve influenzare le inferenze che traiamo dai dati. Queste inferenze,
infatti, devono dirci qualcosa a proposito della realtà empirica e non
possono in nessun modo essere condizionate dalle nostre scelte
arbitrarie che ci portano a scegliere la scala Centigrada piuttosto che
quella Fahrenheit.

Consideriamo ora l'aspetto invariante di una trasformazione lineare, ovvero l'uguaglianza dei rapporti fra intervalli. Prendiamo in esame, ad esempio, tre temperature:
\(20^\circ C = 68^\circ F\),
\(15^\circ C = 59^\circ F\),
\(10^\circ C = 50 ^\circ F\).

È facile rendersi conto del fatto che i rapporti fra intervalli restano costanti indipendentemente dall'unità di misura che è stata scelta:
\[
  \frac{20^\circ C - 10^\circ C}{20^\circ C - 15^\circ C} =
  \frac{68^\circ F - 50^\circ F}{68^\circ F-59^\circ F} = 2.
\]
\end{example}

\hypertarget{scala-di-rapporti}{%
\subsection{Scala di rapporti}\label{scala-di-rapporti}}

Nella scala a rapporti equivalenti la posizione dello zero non è
arbitraria, ma corrisponde all'elemento dotato di intensità nulla
rispetto alla proprietà misurata. Una scala a rapporti equivalenti si
costruisce associando il numero 0 all'elemento con intensità nulla;
viene poi scelta un'unità di misura \(u\) e, ad ogni elemento, si assegna
un numero \(a\) definito come: \[a = \frac{d}{u}\] dove \(d\) rappresenta la
distanza dall'origine. Alle u.s. vengono dunque assegnati dei numeri
tali per cui le differenze e i rapporti tra i numeri riflettono le
differenze e i rapporti tra le intensità della proprietà misurata.

Operazioni aritmetiche sono possibili non solo sulle differenze tra i
valori della scala (come per la scala a intervalli equivalenti), ma
anche sui valori stessi della scala. L'unica arbitrarietà riguarda
l'unità di misura che si utilizza. L'unità di misura può cambiare, ma
qualsiasi unità di misura si scelga, lo zero deve sempre indicare
l'intensità nulla della proprietà considerata.

Le trasformazioni ammissibili a questo livello di scala sono dette
trasformazioni di similarità: \[y' = by, \quad b > 0.\] A questo livello
di scala, a seguito delle trasformazioni ammissibili, rimangono
invariati anche i rapporti: \[\frac{y_i}{y_j} = \frac{y'_i}{y'_j}.\]

\hypertarget{gerarchia-dei-livelli-di-scala-di-misura}{%
\section{Gerarchia dei livelli di scala di misura}\label{gerarchia-dei-livelli-di-scala-di-misura}}

\citet{stevens46} parla di \emph{livelli di scala} poiché i quattro tipi di scala di
misura stanno in una precisa gerarchia: la scala nominale rappresenta il
livello più basso della misurazione, la scala a rapporti equivalenti è
invece il livello più alto.

\begin{longtable}[]{@{}ll@{}}
\toprule
Scale di modalità & Operazioni aritmetiche \\
\midrule
\endhead
nominali & enumerare le classi di equivalenza e/o \\
& le frequenze per ciascuna classe di equivalenza \\
ordinali & enumerare le classi di equivalenza e/o \\
& le frequenze per ciascuna classe di equivalenza \\
intervallari & differenze (rapporti tra differenze) \\
di rapporti & rapporti diretti tra le misure \\
\bottomrule
\end{longtable}

Passando da un livello di misurazione ad uno più alto aumenta il numero di operazioni aritmetiche che possono essere compiute sui valori della scala, come indicato nella figura seguente.

\includegraphics[width=0.8\textwidth,height=\textheight]{images/misurazione_1.png}

Per ciò che riguarda le trasformazioni ammissibili, più il livello di
scala è basso, più le funzioni sono generali (sono minori cioè i vincoli
per passare da una rappresentazione numerica ad un'altra equivalente).
Salendo la gerarchia, la natura delle funzioni di trasformazione si fa
più restrittiva.

\hypertarget{variabili-discrete-o-continue}{%
\section{Variabili discrete o continue}\label{variabili-discrete-o-continue}}

Le variabili a livello di intervalli e di rapporti possono essere
discrete o continue. Le variabili discrete possono assumere alcuni
valori ma non altri. Una volta che l'elenco di valori accettabili è
stato specificato, non ci sono casi che cadono tra questi valori.
Le variabili discrete di solito assumono valori interi.

Quando una variabile può assumere qualsiasi valore entro un intervallo
specificato, allora si dice che la variabile è continua. In teoria, ciò
significa che frazioni e decimali possono essere utilizzati per
raggiungere un livello di precisione qualsiasi. In pratica, a un certo
punto dobbiamo arrotondare i numeri, rendendo tecnicamente la variabile
discreta. In variabili veramente discrete, tuttavia, non è possibile
aumentare a piacimento il livello di precisione della misurazione.

\includegraphics[width=0.8\textwidth,height=\textheight]{images/misurazione_3.png}

\begin{example}
Il numero di biciclette possedute da una persona è una variabile discreta poiché tale variabile può assumere come modalità solo i numeri interi non negativi. Frazioni di bicicletta non hanno senso.
\end{example}

\hypertarget{alcune-misure-sono-migliori-di-altre}{%
\section{Alcune misure sono migliori di altre}\label{alcune-misure-sono-migliori-di-altre}}

In psicologia, ciò che vogliamo misurare non è una caratteristica fisica, ma invece è un concetto teorico inosservabile, ovvero un costrutto.

\begin{quote}
Un costrutto rappresenta il risultato di una fondata riflessione scientifica, non è per definizione accessibile all'osservazione diretta, ma viene inferito dall'osservazione di opportuni indicatori (Sartori, 2005).
\end{quote}

Ad esempio, supponiamo che un docente voglia valutare quanto bene uno studente comprenda la distinzione tra le quattro diverse scale di misura che sono state descritte sopra. Il docente potrebbe predisporre un test costituito da un insieme di domande e potrebbe
contare a quante domande lo studente risponde correttamente. Questo
test, però, può o può non essere una buona misura del costrutto relativo
alla conoscenza effettiva delle quattro scale di misura. Per esempio, se
il docente scrive le domande del test in modo ambiguo o se usa una
linguaggio troppo tecnico che lo studente non conosce, allora i
risultati del test potrebbero suggerire che lo studente non conosce la
materia in questione anche se in realtà questo non è vero. D'altra
parte, se il docente prepara un test a scelta multipla con risposte
errate molto ovvie, allora lo studente può ottenere dei buoni risultati
al test anche senza essere in grado di comprendere adeguatamente le
proprietà delle quattro scale di misura.

In generale non è possibile misurare un costrutto senza una certa
quantità di errore. Poniamoci dunque il problema di determinare in che
modo una misurazione possa dirsi adeguata.

\hypertarget{tipologie-di-errori}{%
\subsection{Tipologie di errori}\label{tipologie-di-errori}}

L'errore è, per definizione, la differenza tra il valore vero e il
valore misurato della grandezza in esame. Gli errori sono classificati
come sistematici (o determinati) e casuali (o indeterminati). Gli errori
casuali sono fluttuazioni, in eccesso o in difetto rispetto al valore
reale, delle singole determinazioni e sono dovuti alle molte variabili
incontrollabili che influenzano ogni misura psicologica. Gli errori
sistematici, invece, influiscono sulla misurazione sempre nello stesso
senso e, solitamente, per una stessa quantità (possono essere additivi o
proporzionali).

Le differenze tra le due tipologie di errori, sistematici e casuali,
introducono i concetti di accuratezza e di precisione della misura. Una
misura viene definita:

\begin{itemize}
\tightlist
\item
  \textbf{accurata}, quando vi è un accordo tra la misura effettuata ed il
  valore reale;
\item
  \textbf{precisa} quando, ripetendo più volte la misura, i risultati
  ottenuti sono concordanti, cioè differiscono in maniera irrilevante
  tra loro.
\end{itemize}

La metafora del tiro a bersaglio illustra la relazione tra precisione e accuratezza.

\begin{figure}

{\centering \includegraphics[width=32.81in]{images/misurazione_4} 

}

\caption{Metafora del tiro al bersaglio.}\label{fig:fig-tiro-bersaglio}
\end{figure}

Per tenere sotto controllo l'incidenza degli errori, sono stati
introdotti in psicologia i concetti di attendibilità e validità.

Uno strumento si dice \textbf{attendibile} quando valuta in modo coerente e
stabile la stessa variabile: i risultati ottenuti si mantengono costanti
dopo ripetute somministrazione ed in assenza di variazioni psicologiche
e fisiche dei soggetti sottoposti al test o cambiamenti dell'ambiente in
cui ha luogo la somministrazione.

L'attendibilità di uno strumento, però, non è sufficiente: in primo luogo uno
strumento di misura deve essere \textbf{valido}, laddove la validità rappresenta
il grado in cui uno strumento misura effettivamente ciò che dovrebbe
misurare. In genere, si fa riferimento ad almeno quattro tipi di
validità.

\begin{itemize}
\tightlist
\item
  La \textbf{validità di costrutto} riguarda il grado in cui un test misura
  ciò per cui è stato costruito. Essa si suddivide in: validità
  convergente e validità divergente. La validità convergente fa
  riferimento alla concordanza tra uno strumento e un altro che misura
  lo stesso costrutto. La validità divergente, al contrario, valuta il
  grado di discriminazione tra strumenti che misurano costrutti
  differenti. Senza validità di costrutto le altre forme di validità
  non hanno senso.
\item
  In base alla \textbf{validità di contenuto}, un test fornisce una misura
  valida di un attributo psicologico se il dominio dell'attributo è
  rappresentato in maniera adeguata dagli item del test. Un requisito
  di base della validità di contenuto è la rilevanza e la
  rappresentatività del contenuto degli item in riferimento
  all'attributo che il test intende misurare.
\item
  La \textbf{validità di criterio} valuta il grado di concordanza tra i
  risultati dello strumento considerato e i risultati ottenuti da
  altri strumenti che misurano lo stesso costrutto, o tra i risultati
  dello strumento considerato e un criterio esterno. Nella validità
  concorrente, costrutto e criterio vengono misurati contestualmente,
  consentendo un confronto immediato. Nella validità predittiva, il
  costrutto viene misurato prima e il criterio in un momento
  successivo, consentendo la valutazione della capacità dello
  strumento di predire un evento futuro.
\item
  Infine, la \textbf{validità di facciata} fa riferimento al grado in cui il
  test appare valido ai soggetti a cui esso è diretto. La validità di
  facciata è importante in ambiti particolari, quali ad esempio la
  selezione del personale per una determinata occupazione. In questo
  caso è ovviamente importante che chi si sottopone al test ritenga
  che il test vada a misurare quegli aspetti che sono importanti per
  le mansioni lavorative che dovranno essere svolte, piuttosto che
  altre cose. In generale, la validità di facciata non è utile, tranne
  in casi particolari.
\end{itemize}

\hypertarget{conclusioni}{%
\section*{Conclusioni}\label{conclusioni}}
\addcontentsline{toc}{section}{Conclusioni}

Una domanda che uno psicologo spesso si pone è: ``sulla base delle
evidenze osservate, possiamo concludere dicendo che l'intervento
psicologico è efficace nel trattamento e nella cura del disturbo?'' Le
considerazioni svolte in questo capitolo dovrebbero farci capire che,
prima di cercare di rispondere a questa domanda con l'analisi statistica
dei dati, devono essere affrontati i problemi della validità e
dell'attendibilità delle misure (oltre a stabilire l'appropriato livello
di scala di misura delle osservazioni). L'attendibilità è un
prerequisito della validità. Se gli errori di misurazione sono troppo
grandi, i dati sono inutili. Inoltre, uno strumento di misurazione può
essere preciso ma non valido. La validità e l'attendibilità delle
misurazioni sono dunque entrambe necessarie.

In generale, l'attendibilità e la validità delle misure devono essere
valutate per capire se i dati raccolti da un ricercatore siano adeguati
(1) per fornire una risposta alla domanda della ricerca, e (2) per
giungere alla conclusione proposta dal ricercatore alla luce dei
risultati dell'analisi statistica che è stata eseguita. È chiaro che le
informazioni fornite in questo capitolo si limitano a scalfire la
superficie di questi problemi. I concetti qui introdotti, però, devono
sempre essere tenuti a mente e costituiscono il fondamento di quanto
verrà esposto nei capitoli successivi.

\hypertarget{appendix-appendix}{%
\appendix}


\hypertarget{simbologia-di-base}{%
\chapter{Simbologia di base}\label{simbologia-di-base}}

Per una scrittura più sintetica possono essere utilizzati alcuni simboli
matematici.

\begin{itemize}
\item
  L'operatore logico booleano \(\land\) significa ``e'' (congiunzione
  forte) mentre il connettivo di disgiunzione \(\lor\) significa ``o''
  (oppure) (congiunzione debole).
\item
  Il quantificatore esistenziale \(\exists\) vuol dire ``esiste almeno
  un'' e indica l'esistenza di almeno una istanza del concetto/oggetto
  indicato. Il quantificatore esistenziale di unicità \(\exists!\)
  (``esiste soltanto un'') indica l'esistenza di esattamente una istanza
  del concetto/oggetto indicato. Il quantificatore esistenziale
  \(\nexists\) nega l'esistenza del concetto/oggetto indicato.
\item
  Il quantificatore universale \(\forall\) vuol dire ``per ogni.''
\item
  L'implicazione logica ``\(\Rightarrow\)'' significa ``implica'' (se
  \ldots allora). \(P \Rightarrow Q\) vuol dire che \(P\) è condizione
  sufficiente per la verità di \(Q\) e che \(Q\) è condizione necessaria
  per la verità di \(P\).
\item
  L'equivalenza matematica ``\(\iff\)'' significa ``se e solo se'' e indica
  una condizione necessaria e sufficiente, o corrispondenza biunivoca.
\item
  Il simbolo \(\vert\) si legge ``tale che.''
\item
  Il simbolo \(\triangleq\) (o \(:=\)) si legge ``uguale per definizione.''
\item
  Il simbolo \(\Delta\) indica la differenza fra due valori della
  variabile scritta a destra del simbolo.
\item
  Il simbolo \(\propto\) si legge ``proporzionale a.''
\item
  Il simbolo \(\approx\) si legge ``circa.''
\item
  Il simbolo \(\in\) della teoria degli insiemi vuol dire ``appartiene'' e
  indica l'appartenenza di un elemento ad un insieme. Il simbolo
  \(\notin\) vuol dire ``non appartiene.''
\item
  Il simbolo \(\subseteq\) si legge ``è un sottoinsieme di'' (può
  coincidere con l'insieme stesso). Il simbolo \(\subset\) si legge ``è
  un sottoinsieme proprio di.''
\item
  Il simbolo \(\#\) indica la cardinalità di un insieme.
\item
  Il simbolo \(\cap\) indica l'intersezione di due insiemi. Il simbolo
  \(\cup\) indica l'unione di due insiemi.
\item
  Il simbolo \(\emptyset\) indica l'insieme vuoto o evento impossibile.
\item
  In matematica, \(\argmax\) identifica l'insieme dei punti per i quali una data funzione raggiunge il suo massimo. In altre parole, \(\argmax_x f(x)\) è l'insieme dei valori di \(x\) per i quali \(f(x)\) raggiunge il valore più alto.
\end{itemize}

\hypertarget{numeri-binari-interi-razionali-irrazionali-e-reali}{%
\chapter{Numeri binari, interi, razionali, irrazionali e reali}\label{numeri-binari-interi-razionali-irrazionali-e-reali}}

\hypertarget{numeri-binari}{%
\section{Numeri binari}\label{numeri-binari}}

I numeri più semplici sono quelli binari, cioè zero o uno. Useremo spesso
numeri binari per indicare se qualcosa è vero o falso, presente o
assente.

I numeri binari sono molto utili per ottenere facilmente delle statistiche riassuntive in R.Supponiamo di chiedere a 10 studenti ``Ti piacciono i mirtilli?'' Poniamo che le risposte siano le seguenti:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{opinion }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{\textquotesingle{}Yes\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}No\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}Yes\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}No\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}Yes\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}No\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}Yes\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}Yes\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}Yes\textquotesingle{}}\NormalTok{,}\StringTok{\textquotesingle{}Yes\textquotesingle{}}\NormalTok{)}
\NormalTok{opinion}
\CommentTok{\#\textgreater{}  [1] "Yes" "No"  "Yes" "No"  "Yes" "No"  "Yes" "Yes" "Yes"}
\CommentTok{\#\textgreater{} [10] "Yes"}
\end{Highlighting}
\end{Shaded}

Tali risposte possono essere ricodificate nei termini di valori di
verità, ovvero, vero e falso, generalmente denotati rispettivamente come
1 e 0. In R tale ricodifica può essere effettuata mediante l'operatore
\texttt{==} che è un test per l'uguaglianza e restituisce il valore logico VERO
se i due oggetti valutati sono uguali e FALSO se non lo sono:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{opinion }\OtherTok{\textless{}{-}}\NormalTok{ opinion }\SpecialCharTok{==} \StringTok{"Yes"}
\NormalTok{opinion}
\CommentTok{\#\textgreater{}  [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE}
\CommentTok{\#\textgreater{} [10]  TRUE}
\end{Highlighting}
\end{Shaded}

R considera i valori di verità e i numeri binari in modo equivalente, con
TRUE uguale a 1 e FALSE uguale a zero. Di conseguenza, possiamo
effettuare operazioni algebriche sui valori logici VERO e FALSO.
Nell'esempio, possiamo sommare i valori di verità e dividere per 10

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(opinion) }\SpecialCharTok{/} \FunctionTok{length}\NormalTok{(opinion)}
\CommentTok{\#\textgreater{} [1] 0.7}
\end{Highlighting}
\end{Shaded}

in modo tale da calcolare una propozione, il che ci consente di concludere che 7 risposte su 10 sono positive.

\hypertarget{numeri-interi}{%
\section{Numeri interi}\label{numeri-interi}}

Un numero intero è un numero senza decimali. Si dicono \textbf{naturali} i
numeri che servono a contare, come 1, 2, \ldots{} L'insieme dei numeri
naturali si indica con il simbolo \(\mathbb{N}\). È anche necessario
introdurre i numeri con il segno per poter trattare grandezze negative.
Si ottengono così l'insieme numerico dei numeri interi relativi:
\(\mathbb{Z} = \{0, \pm 1, \pm 2, \dots \}\)

\hypertarget{numeri-razionali}{%
\section{Numeri razionali}\label{numeri-razionali}}

I numeri razionali sono i numeri frazionari \(m/n\), dove \(m, n \in N\),
con \(n \neq 0\). Si ottengono così i numeri razionali:
\(\mathbb{Q} = \{\frac{m}{n} \,\vert\, m, n \in \mathbb{Z}, n \neq 0\}\).
È evidente che \(\mathbb{N} \subseteq \mathbb{Z} \subseteq \mathbb{Q}\).
Anche in questo caso è necessario poter trattare grandezze negative. I
numeri razionali non negativi sono indicati con
\(\mathbb{Q^+} = \{q \in \mathbb{Q} \,\vert\, q \geq 0\}\).

\hypertarget{numeri-irrazionali}{%
\section{Numeri irrazionali}\label{numeri-irrazionali}}

Tuttavia, non tutti i punti di una retta \(r\) possono essere
rappresentati mediante i numeri interi e razionali. È dunque necessario
introdurre un'altra classe di numeri. Si dicono \textbf{irrazionali}, e sono
denotati con \(\mathbb{R}\), i numeri che possono essere scritti come una
frazione \(a / b\), con \(a\) e \(b\) interi e \(b\) diverso da 0. I numeri
irrazionali sono i numeri illimitati e non periodici che quindi non
possono essere espressi sotto forma di frazione. Per esempio,
\(\sqrt{2}\), \(\sqrt{3}\) e \({\displaystyle \pi =3,141592\ldots}\) sono
numeri irrazionali.

\hypertarget{numeri-reali}{%
\section{Numeri reali}\label{numeri-reali}}

I punti della retta \(r\) sono quindi ``di più'' dei numeri razionali. Per
poter rappresentare tutti i punti della retta abbiamo dunque bisogno dei
numeri \textbf{reali}. I numeri reali possono essere positivi, negativi o nulli
e comprendono, come casi particolari, i numeri interi, i numeri
razionali e i numeri irrazionali. Spesso in statisticac il numero dei
decimali indica il grado di precisione della misurazione.

\hypertarget{intervalli}{%
\section{Intervalli}\label{intervalli}}

Un intervallo si dice chiuso se gli estremi sono compresi
nell'intervallo, aperto se gli estremi non sono compresi. Le
caratteristiche degli intervalli sono riportate nella tabella seguente.

\begin{longtable}[]{@{}cll@{}}
\toprule
Intervallo & & \\
\midrule
\endhead
chiuso & \([a, b]\) & \(a \leq x \leq b\) \\
aperto & \((a, b)\) & \(a < x < b\) \\
chiuso a sinistra e aperto a destra & \([a, b)\) & \(a \leq x < b\) \\
aperto a sinistra e chiuso a destra & \((a, b]\) & \(a < x \leq b\) \\
\bottomrule
\end{longtable}

\hypertarget{insiemistica}{%
\chapter{Insiemi}\label{insiemistica}}

Un insieme (o collezione, classe, gruppo, \ldots) è un concetto primitivo,
ovvero è un concetto che già possediamo. Georg Cantor l'ha definito nel
modo seguente:

\begin{quote}
un insieme è una collezione di oggetti, determinati e distinti, della nostra percezione o del nostro pensiero, concepiti come un tutto unico; tali oggetti si dicono elementi dell'insieme.
\end{quote}

Mentre non è rilevante la natura degli oggetti che costituiscono
l'insieme, ciò che importa è distinguere se un dato oggetto appartenga o
meno ad un insieme. Deve essere vera una delle due possibilità: il dato
oggetto è un elemento dell'insieme considerato oppure non è elemento
dell'insieme considerato. Due insiemi \(A\) e \(B\) si dicono uguali se sono
formati dagli stessi elementi, anche se disposti in ordine diverso:
\(A=B\). Due insiemi \(A\) e \(B\) si dicono diversi se non contengono gli
stessi elementi: \(A \neq B\). Ad esempio, i seguenti insiemi sono uguali:
\[\{1, 2, 3\} = \{3, 1, 2\} = \{1, 3, 2\}= \{1, 1, 1, 2, 3, 3, 3\}.\]
Gli insiemi sono denotati da una lettera maiuscola, mentre le lettere
minuscole, di solito, designano gli elementi di un insieme. Per esempio,
un generico insieme \(A\) si indica con
\[A = \{a_1, a_2, \dots, a_n\}, \quad \text{con~} n > 0.\]

La scrittura \(a \in A\) dice che \(a\) è un elemento di \(A\). Per dire che
\(b\) non è un elemento di \(A\) si scrive \(b \notin A.\)

Per quegli insiemi i cui elementi soddisfano una certa proprietà che li
caratterizza, tale proprietà può essere usata per descrivere più
sinteticamente l'insieme:
\[
A = \{x ~\vert~ \text{proprietà posseduta da~} x\},
\]
che si legge come ``\(A\) è l'insieme degli elementi \(x\) per cui è vera la proprietà
indicata.'' Per esempio, per indicare l'insieme \(A\) delle coppie di
numeri reali \((x,y)\) che appartengono alla parabola \(y = x^2 + 1\) si può
scrivere:
\[
A = \{(x,y) ~\vert~ y = x^2 + 1\}.
\]
Dati due insiemi \(A\) e \(B\), diremo che \(A\) è un \emph{sottoinsieme} di \(B\) se
e solo se tutti gli elementi di \(A\) sono anche elementi di \(B\):
\[A \subseteq B \iff (\forall x \in A \Rightarrow x \in B).\] Se esiste
almeno un elemento di \(B\) che non appartiene ad \(A\) allora diremo che
\(A\) è un \emph{sottoinsieme proprio} di \(B\):
\[
A \subset B \iff (A \subseteq B, \exists~ x \in B ~\vert~ x \notin A).
\]
Un altro insieme, detto \emph{insieme delle parti}, o insieme potenza, che si
associa all'insieme \(A\) è l'insieme di tutti i sottoinsiemi di \(A\),
inclusi l'insieme vuoto e \(A\) stesso. Per esempio, per l'insieme
\(A = \{a, b, c\}\), l'insieme delle parti è:
\[
\mathcal{P}(A) = \{
\emptyset, \{a\}, \{b\}, \{c\},
 \{a, b\}, \{a, c\}, \{c, b\},
 \{a, b, c\}
\}.
\]

\hypertarget{operazioni-tra-insiemi}{%
\section{Operazioni tra insiemi}\label{operazioni-tra-insiemi}}

Si definisce \textbf{intersezione} di \(A\) e \(B\) l'insieme \(A \cap B\) di tutti
gli elementi \(x\) che appartengono ad \(A\) e contemporaneamente a \(B\):
\[A \cap B = \{x ~\vert~ x \in A \land x \in B\}.\]

Si definisce \textbf{unione} di \(A\) e \(B\) l'insieme \(A \cup B\) di tutti gli
elementi \(x\) che appartengono ad \(A\) o a \(B\), cioè
\[
A \cup B = \{x ~\vert~ x \in A \lor x \in B\}.
\]

\textbf{Differenza}. Si indica con \(A \setminus B\) l'insieme degli elementi di
\(A\) che non appartengono a \(B\):
\[A \setminus B = \{x ~\vert~ x \in A \land x \notin B\}.\]

\textbf{Insieme complementare}. Nel caso che sia \(B \subseteq A\), l'insieme
differenza \(A \setminus B\) è detto insieme complementare di \(B\) in \(A\) e
si indica con \(B^C\).

Dato un insieme \(S\), una \textbf{partizione} di \(S\) è una collezione di
sottoinsiemi di \(S\), \(S_1, \dots, S_k\), tali che
\[S = S_1 \cup S_2 \cup \dots S_k\] e
\[S_i \cap S_j, \quad \text{con~} i \neq j.\]

La relazione tra unione, intersezione e insieme complementare è data
dalle leggi di DeMorgan: \[(A \cup B)^c = A^c \cap B^c,\]
\[(A \cap B)^c = A^c \cup B^c.\]

\hypertarget{diagrammi-di-eulero-venn}{%
\section{Diagrammi di Eulero-Venn}\label{diagrammi-di-eulero-venn}}

In molte situazioni è utile servirsi dei cosiddetti diagrammi di
Eulero-Venn per rappresentare gli insiemi e verificare le proprietà
delle operazioni tra insiemi (si veda la figura~\ref{fig:sets-venn-diagrams}.
I diagrammi di Venn sono così nominati in onore del matematico inglese del diciannovesimo secolo John Venn anche se Leibnitz e Eulero avevano già in precedenza utilizzato rappresentazioni simili.
In tale rappresentazione, gli insiemi sono individuati da regioni del piano delimitate da una curva chiusa. Nel caso di insiemi finiti, è possibile evidenziare esplicitamente alcuni elementi di un insieme mediante punti, quando si
possono anche evidenziare tutti gli elementi degli insiemi considerati.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{images/sets-venn-diagrams} 

}

\caption{In tutte le figure $S$ è la regione delimitata dal rettangolo, $L$ è la regione all'interno del cerchio di sinistra e $R$ è la regione all'interno del cerchio di destra. La regione evidenziata mostra l'insieme indicato sotto ciascuna figura.}\label{fig:sets-venn-diagrams}
\end{figure}

I diagrammi di Eulero-Venn che forniscono una dimostrazione delle leggi
di DeMorgan sono forniti nella figura \ref{fig:demorgan}.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{images/demorgan} 

}

\caption{Dimostrazione delle leggi di DeMorgan.}\label{fig:demorgan}
\end{figure}

\hypertarget{coppie-ordinate-e-prodotto-cartesiano}{%
\section{Coppie ordinate e prodotto cartesiano}\label{coppie-ordinate-e-prodotto-cartesiano}}

Una coppia ordinata \((x,y)\) è l'insieme i cui elementi sono \(x \in A\) e
\(y \in B\) e nella quale \(x\) è la prima componente (o prima coordinata),
\(y\) la seconda. L'insieme di tutte le coppie ordinate costruite a
partire dagli insiemi \(A\) e \(B\) viene detto \textbf{prodotto cartesiano}:
\[A \times B = \{(x, y) ~\vert~ x \in A \land y \in B\}.\] Ad esempio,
sia \(A = \{1, 2, 3\}\) e \(B = \{a, b\}\). Allora,
\[\{1, 2\} \times \{a, b, c\} = \{(1, a), (1, b), (1, c), (2, a), (2, b), (2, c)\}.\]

\hypertarget{cardinalituxe0}{%
\section{Cardinalità}\label{cardinalituxe0}}

Si definisce \textbf{cardinalità} (o potenza) di un insieme finito il numero
degli elementi dell'insieme. Viene indicata con \(\vert A\vert, \#(A)\) o
\(\text{c}(A)\).

\hypertarget{sommatorie}{%
\chapter{Simbolo di somma (sommatorie)}\label{sommatorie}}

Le somme si incontrano costantemente in svariati contesti matematici e statistici quindi abbiamo bisogno di una notazione adeguata che ci consenta di gestirle. La somma dei primi \(n\) numeri interi può essere scritta come \(1+2+\dots+(n-1)+n\), dove `\(\dots\)' ci dice di completare la sequenza definita dai termini che vengono prima e dopo. Ovviamente, una notazione come \(1+7+\dots+73.6\) non avrebbe alcun senso senza qualche altro tipo di precisazione. In generale, nel seguito incontreremo delle somme nella forma
\begin{equation}
x_1+x_2+\dots+x_n,\notag
\end{equation}
dove \(x_i\) è un numero che è stato definito altrove. La notazione precedente, che fa uso dei tre puntini di sospensione, è utile in alcuni contesti ma in altri risulta ambigua. Pertanto la notazione di uso corrente è del tipo
\begin{equation}
  \sum_{i=1}^n x_i\notag
\end{equation}
\noindent
e si legge ``sommatoria per \(i\) che va da \(1\) a \(n\) di \(x_i\).'\,' Il simbolo \(\sum\) (lettera sigma maiuscola dell'alfabeto greco) indica l'operazione di somma, il simbolo \(x_i\) indica il generico addendo della sommatoria, le lettere \(1\) ed \(n\) indicano i cosiddetti \emph{estremi della sommatoria}, ovvero l'intervallo (da \(1\) fino a \(n\) estremi inclusi) in cui deve variare l'indice \(i\) allorché si sommano gli addendi \(x_i\).
Solitamente l'estremo inferiore è \(1\) ma potrebbe essere qualsiasi altri numero \(m < n\). Quindi
\[
  \sum_{i=1}^n x_i = x_1 + x_{2} + \dots + x_{n}.
\]
Per esempio, se i valori \(x\) sono \(\{3, 11, 4, 7\}\), si avrà
\[
  \sum_{i=1}^4 x_i = 3+11+4+7 = 25 
\]
laddove \(x_1 = 3\), \(x_2 = 11\), eccetera. La quantità \(x_i\) nella formula precedente si dice l'\emph{argomento} della sommatoria, mentre la variabile \(i\), che prende i valori naturali successivi indicati nel simbolo, si dice \emph{indice} della sommatoria.

La notazione di sommatoria può anche essere fornita nella forma seguente
\begin{equation}
  \sum_{P(i)} x_i\notag
\end{equation}
dove \(P(i)\) è qualsiasi proposizione riguardante \(i\) che può essere vera o falsa. Quando è ovvio che si vogliono sommare tutti i valori di \(n\) osservazioni, la notazione può essere semplificata nel modo seguente: \(\sum_{i} x_i\) oppure \(\sum x_i\). Al posto di \(i\) si possono trovare altre lettere: \(k, j, l, \dots\),.

\hypertarget{manipolazione-di-somme}{%
\section{Manipolazione di somme}\label{manipolazione-di-somme}}

È conveniente utilizzare le seguenti regole per semplificare i calcoli che coinvolgono l'operatore della sommatoria.

\hypertarget{proprietuxe0-1}{%
\subsection{Proprietà 1}\label{proprietuxe0-1}}

La sommatoria di \(n\) valori tutti pari alla stessa costante \(a\) è pari a \(n\) volte la costante stessa:
\[
  \sum_{i=1}^{n} a =  \underbrace{a + a + \dots + a}_{n~\text{volte}} = n a.
  \]

\hypertarget{proprietuxe0-2-proprietuxe0-distributiva}{%
\subsection{Proprietà 2 (proprietà distributiva)}\label{proprietuxe0-2-proprietuxe0-distributiva}}

Nel caso in cui l'argomento contenga una costante, è possibile riscrivere la sommatoria. Ad esempio con
\[
  \sum_{i=1}^{n} a x_i =  a x_1 + a x_2 + \dots + a x_n
  \]
è possibile raccogliere la costante \(a\) e fare \(a(x_1 +x_2 + \dots + x_n)\). Quindi possiamo scrivere
\[
  \sum_{i=1}^{n} a x_i =  a  \sum_{i=1}^{n} x_i.
  \]

\hypertarget{proprietuxe0-3-proprietuxe0-associativa}{%
\subsection{Proprietà 3 (proprietà associativa)}\label{proprietuxe0-3-proprietuxe0-associativa}}

Nel caso in cui
\[
  \sum_{i=1}^{n} (a + x_i) =  (a + x_1) +  (a + x_1) + \dots  (a + x_n)
  \]
si ha che
\[
  \sum_{i=1}^{n} (a + x_i) =  n a + \sum_{i=1}^{n} x_i.
  \]
È dunque chiaro che in generale possiamo scrivere
\[
  \sum_{i=1}^{n} (x_i + y_i) =  \sum_{i=1}^{n} x_i + \sum_{i=1}^{n} y_i.
  \]

\hypertarget{proprietuxe0-4}{%
\subsection{Proprietà 4}\label{proprietuxe0-4}}

Se deve essere eseguita un'operazione algebrica (innalzamento a potenza, logaritmo, ecc.) sull'argomento della sommatoria, allora tale operazione algebrica deve essere eseguita prima della somma. Per esempio,
\[
\sum_{i=1}^{n} x_i^2 = x_1^2 + x_2^2 + \dots + x_n^2 \neq \left(\sum_{i=1}^{n} x_i \right)^2.
\]

\hypertarget{proprietuxe0-5}{%
\subsection{Proprietà 5}\label{proprietuxe0-5}}

Nel caso si voglia calcolare \(\sum_{i=1}^{n} x_i y_i\), il prodotto tra i punteggi appaiati deve essere eseguito prima e la somma dopo:
\[
\sum_{i=1}^{n} x_i y_i = x_1 y_1 + x_2 y_2 + \dots + x_n y_n,
\]
infatti, \(a_1 b_1 + a_2 b_2 \neq (a_1 + a_2)(b_1 + b_2)\).

\hypertarget{doppia-sommatoria}{%
\section{Doppia sommatoria}\label{doppia-sommatoria}}

È possibile incontrare la seguente espressione in cui figurano una doppia sommatoria e un doppio indice:
\[
\sum_{i=1}^{n}\sum_{j=1}^{m} x_{ij}.
\]
La doppia sommatoria comporta che per ogni valore dell'indice esterno, \(i\) da \(1\) ad \(n\), occorre sviluppare la seconda sommatoria per \(j\) da \(1\) ad \(m\). Quindi,
\[
\sum_{i=1}^{3}\sum_{j=4}^{6} x_{ij} = (x_{1, 4} + x_{1, 5} + x_{1, 6}) + (x_{2, 4} + x_{2, 5} + x_{2, 6}) + (x_{3, 4} + x_{3, 5} + x_{3, 6}).
\]

Un caso particolare interessante di doppia sommatoria è il seguente:
\[
\sum_{i=1}^{n}\sum_{j=1}^{n} x_i y_j
\]
Si può osservare che nella sommatoria interna (quella che dipende dall'indice \(j\)), la quantità \(x_i\) è costante, ovvero non dipende dall'indice (che è \(j\)). Allora possiamo estrarre \(x_i\) dall'operatore di sommatoria interna e scrivere
\[
\sum_{i=1}^{n} \left( x_i \sum_{j=1}^{n} y_j \right).
\]
Allo stesso modo si può osservare che nell'argomento della sommatoria esterna la quantità costituita dalla sommatoria in \(j\) non dipende dall'indice \(i\) e quindi questa quantità può essere estratta dalla sommatoria esterna. Si ottiene quindi
\[
\sum_{i=1}^{n}\sum_{j=1}^{n} x_i y_j = \sum_{i=1}^{n} \left( x_i \sum_{j=1}^{n} y_j \right) = \sum_{i=1}^{n}\ x_i \sum_{j=1}^{n} y_j.
\]

\begin{example}
Si verifichi quanto detto sopra nel caso particolare di \(x = \{2, 3, 1\}\) e \(y = \{1, 4, 9\}\), svolgendo prima la doppia sommatoria per poi verificare che quanto così ottenuto sia uguale al prodotto delle due sommatorie.

\begin{align}
\sum_{i=1}^3 \sum_{j=1}^3 x_i y_j &= x_1y_1 + x_1y_2 + x_1y_3 + 
x_2y_1 + x_2y_2 + x_2y_3 + 
x_3y_1 + x_3y_2 + x_3y_3 \notag\\
&= 2 \times (1+4+9) + 3 \times (1+4+9) + 2 \times (1+4+9) = 84,\notag
\end{align}
ovvero
\[
(2 + 3 + 1) \times (1+4+9) = 84.
\]
\end{example}

\hypertarget{sommatorie-e-produttorie-e-operazioni-vettoriali-in-r}{%
\section{\texorpdfstring{Sommatorie (e produttorie) e operazioni vettoriali in \texttt{R}}{Sommatorie (e produttorie) e operazioni vettoriali in R}}\label{sommatorie-e-produttorie-e-operazioni-vettoriali-in-r}}

Si noti che la notazione
\[
\sum_{n=0}^4 3n
\]
non è altro che un ciclo \texttt{for}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sum }\OtherTok{=} \DecValTok{0}\NormalTok{;}
\ControlFlowTok{for}\NormalTok{ (}\AttributeTok{n =} \DecValTok{0}\NormalTok{; n }\SpecialCharTok{\textless{}=} \DecValTok{4}\NormalTok{; n}\SpecialCharTok{++}\NormalTok{) \{}
\NormalTok{  sum }\SpecialCharTok{+}\ErrorTok{=} \DecValTok{3} \SpecialCharTok{*}\NormalTok{ n;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

scritto in C, oppure

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sum }\OtherTok{\textless{}{-}} \DecValTok{0}
\ControlFlowTok{for}\NormalTok{ (n }\ControlFlowTok{in} \DecValTok{0}\SpecialCharTok{:}\DecValTok{4}\NormalTok{) \{}
\NormalTok{  sum }\OtherTok{=}\NormalTok{ sum }\SpecialCharTok{+} \DecValTok{3} \SpecialCharTok{*}\NormalTok{ n}
\NormalTok{\}}
\NormalTok{sum}
\CommentTok{\#\textgreater{} [1] 30}
\end{Highlighting}
\end{Shaded}

scritto in \texttt{R}. In maniera equivalente, e più semplice, possiamo scrivere

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(}\DecValTok{3} \SpecialCharTok{*}\NormalTok{ (}\DecValTok{0}\SpecialCharTok{:}\DecValTok{4}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] 30}
\end{Highlighting}
\end{Shaded}

Allo stesso modo, la notazione
\[
\prod_{n=1}^{4} 2n
\]
è equivalente al ciclo \texttt{for}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prod }\OtherTok{\textless{}{-}} \DecValTok{1}
\ControlFlowTok{for}\NormalTok{ (n }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{) \{}
\NormalTok{  prod }\OtherTok{\textless{}{-}}\NormalTok{ prod }\SpecialCharTok{*} \DecValTok{2} \SpecialCharTok{*}\NormalTok{ n}
\NormalTok{\}}
\NormalTok{prod}
\CommentTok{\#\textgreater{} [1] 384}
\end{Highlighting}
\end{Shaded}

il che si può scrivere, più semplicemente, come

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{prod}\NormalTok{(}\DecValTok{2} \SpecialCharTok{*}\NormalTok{ (}\DecValTok{1}\SpecialCharTok{:}\DecValTok{4}\NormalTok{))}
\CommentTok{\#\textgreater{} [1] 384}
\end{Highlighting}
\end{Shaded}

\hypertarget{funs-exp-log}{%
\chapter{Funzioni esponenziale e logaritmica}\label{funs-exp-log}}

\hypertarget{funzione-esponenziale}{%
\section{Funzione esponenziale}\label{funzione-esponenziale}}

\begin{definition}
La funzione esponenziale con base \(a\) è
\begin{equation}
f(x) = a^x
\end{equation}
\noindent
dove \(a > 0\), \(a \neq 1\) e \(x\) è qualsiasi numero reale.
\end{definition}

La base \(a = 1\) è esclusa perché produce \(f(x) = 1^x = 1\), la quale è una costante, non una funzione esponenziale.

Per esempio, un grafico della funzione esponenziale di base 2 si trova con

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exp\_base2 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) \{}
  \DecValTok{2}\SpecialCharTok{\^{}}\NormalTok{x}
\NormalTok{\}}
\FunctionTok{tibble}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{5}\NormalTok{, }\DecValTok{5}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ x)) }\SpecialCharTok{+}
  \FunctionTok{stat\_function}\NormalTok{(}\AttributeTok{fun =}\NormalTok{ exp\_base2)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{906_logaritmi_files/figure-latex/unnamed-chunk-1-1} \end{center}

Se usiamo la base 4 troviamo

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exp\_base4 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) \{}
  \DecValTok{4}\SpecialCharTok{\^{}}\NormalTok{x}
\NormalTok{\}}
\FunctionTok{tibble}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{5}\NormalTok{, }\DecValTok{5}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ x)) }\SpecialCharTok{+}
  \FunctionTok{stat\_function}\NormalTok{(}\AttributeTok{fun =}\NormalTok{ exp\_base4)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{906_logaritmi_files/figure-latex/unnamed-chunk-2-1} \end{center}

Oppure

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exp\_base4 }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) \{}
  \DecValTok{4}\SpecialCharTok{\^{}{-}}\NormalTok{\{}
\NormalTok{    x}
\NormalTok{  \}}
\NormalTok{\}}
\FunctionTok{tibble}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{5}\NormalTok{, }\DecValTok{5}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ x)) }\SpecialCharTok{+}
  \FunctionTok{stat\_function}\NormalTok{(}\AttributeTok{fun =}\NormalTok{ exp\_base4)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{906_logaritmi_files/figure-latex/unnamed-chunk-3-1} \end{center}

In molte applicazioni la scelta più conveniente per la base è il numero irrazionale \$e = 2.718281828\dots. Questo numero è chiamato la base naturale. La funzione \(f(x) = e^x\) è chiamata funzione esponenziale naturale.

Per esempio, abbiamo

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exp\_base\_e }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) \{}
  \FunctionTok{exp}\NormalTok{(x)}
\NormalTok{\}}
\FunctionTok{tibble}\NormalTok{(}\AttributeTok{x =} \FunctionTok{c}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{2}\NormalTok{, }\FloatTok{1.5}\NormalTok{)) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ x)) }\SpecialCharTok{+}
  \FunctionTok{stat\_function}\NormalTok{(}\AttributeTok{fun =}\NormalTok{ exp\_base\_e)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{906_logaritmi_files/figure-latex/unnamed-chunk-4-1} \end{center}

\hypertarget{funzione-logaritmica}{%
\section{Funzione logaritmica}\label{funzione-logaritmica}}

La funzione logaritmica è la funzione inversa della funzione espenziale.

\begin{definition}
Siano \(a > 0\), \(a \neq 1\). Per \(x > 0\)
\begin{equation}
y = \log_a x \quad \text{se e solo se } x = a^y.
\end{equation}
\noindent
La funzione data da
\begin{equation}
f(x) = \log_a x
\end{equation}
\noindent
è chiamata funzione logaritmica.
\end{definition}

Le seguenti equazioni sono dunque equivalenti:

\begin{equation}
y = \log_a x \qquad x = a^y.
\end{equation}

La prima equazione è in forma logaritmica e la seconda è in forma esponenziale. Ad esempio, l'equazione logaritmica \(2 = \log_3 9\) può essere riscritta in forma esponenziale come \(9 = 3^2\).

Quando valutiamo i logaritmi, dobbiamo ricordare che un logaritmo è un esponente. Ciò significa che \(\log_a x\) è l'esponente a cui deve essere elevato \(a\) per ottenere \(x\).

\hypertarget{least-squares}{%
\chapter{Minimi quadrati}\label{least-squares}}

Nella trattazione classica del modello di regressione, \(y_i = \alpha + \beta x_i + e_i\), i coefficienti \(a = \hat{\alpha}\) e \(b = \hat{\beta}\) vengono stimati in modo tale da minimizzare i residui

\begin{equation}
e_i = y_i - \hat{\alpha} - \hat{\beta} x_i.
\label{eq:residuals}
\end{equation}
In altri termini, il residuo \(i\)-esimo è la differenza fra l'ordinata del punto (\(x_i\), \(y_i\)) e quella del punto di ascissa \(x_i\) sulla retta di regressione campionaria.

Per determinare i coefficienti \(a\) e \(b\) della retta \(y_i = a + b x_i + e_i\) non è sufficiente minimizzare la somma dei residui \(\sum_{i=1}^{n}e_i\), in quanto i residui possono essere sia positivi che negativi e la loro somma può essere molto prossima allo zero anche per differenze molto grandi tra i valori osservati e la retta di regressione. Infatti, ciascuna retta passante per il punto (\(\bar{x}, \bar{y}\)) ha \(\sum_{i=1}^{n}e_i=0\).

Una retta passante per il punto (\(\bar{x}, \bar{y}\)) soddisfa l'equazione \(\bar{y} = a + b \bar{x}\).
Sottraendo tale equazione dall'equazione \(y_i = a + b x_i + e_i\) otteniamo
\[
y_i - \bar{y} =  b (x_i - \bar{x}) + e_i. 
\]
Sommando su tutte le osservazioni, si ha che
\begin{equation}
\sum_{i=1}^n e_i = \sum_{i=1}^n (y_i - \bar{y} ) -  b \sum_{i=1}^n (x_i - \bar{x}) = 0 - b(0) = 0. 
\label{eq:res-sum-zero}
\end{equation}

Questo problema viene risolto scegliendo i coefficienti \(a\) e \(b\) che minimizzano, non tanto la somma dei residui, ma bensì l'\emph{errore quadratico}, cioè la somma dei quadrati degli errori:

\begin{equation}
S(a, b) = \sum_{i=1}^{n} e_i^2 = \sum (y_i - a - b x_i)^2.
\end{equation}

Il metodo più diretto per determinare quelli che vengono chiamati i \emph{coefficienti dei minimi quadrati} è quello di trovare le derivate parziali della funzione \(S(a, b)\) rispetto ai coefficienti \(a\) e \(b\):

\begin{align}
\frac{\partial S(a,b)}{\partial a} &= \sum (-1)(2)(y_i - a - b x_i), \notag \\
\frac{\partial S(a,b)}{\partial b} &= \sum (-x_i)(2)(y_i - a - b x_i).
\end{align}

Ponendo le derivate uguali a zero e dividendo entrambi i membri per \(-2\) si ottengono le \emph{equazioni normali}

\begin{align}
 an + b \sum x_i &= \sum y_i, \notag \\
 a \sum x_i + b \sum x_i^2 &= \sum x_i y_i. 
 \label{eq:form-normali}
\end{align}

I coefficienti dei minimi quadrati \(a\) e \(b\) si trovano risolvendo le \eqref{eq:form-normali} e sono uguali a:

\begin{align}
a &= \bar{y} - b \bar{x},\\
b &= \frac{\sum (x_i - \bar{x}) (y_i - \bar{y})}{\sum (x_i - \bar{x})^2}.
\label{eq:minsq-ab}
\end{align}

\hypertarget{massima-verosimiglianza}{%
\subsection{Massima verosimiglianza}\label{massima-verosimiglianza}}

Se gli errori del modello lineare sono indipendenti e distribuiti secondo una Normale, così che \(y_i \sim \mathcal{N}(\alpha + \beta x, \sigma^2)\) per ciascun \(i\), allora le stime dei minimi quadrati di \(\alpha\) e \(\beta\) corrispondono alla stima di massima verosimiglianza. La funzione di verosimiglianza del modello di regressione è definita come la funzione di densità di probabilità dei dati, dati i parametri e i predittori:

\begin{equation}
p(y \mid \alpha, \beta, \sigma, x) = \prod_{i=1}^n \mathcal{N}(y_i \mid \alpha, \beta x_i, \sigma^2). 
\label{eq:ml-reg}
\end{equation}

Massimizzare la \eqref{eq:ml-reg} conduce alle stime dei minimi quadrati \eqref{eq:minsq-ab}.

\hypertarget{introduzione-al-linguaggio-r}{%
\chapter{Introduzione al linguaggio R}\label{introduzione-al-linguaggio-r}}

In questa sezione della dispensa saranno presentate le caratteristiche di base e la filosofia dell'ambiente \texttt{R}, passando poi a illustrare le strutture dati e le principali strutture di controllo. Verranno introdotte alcune funzioni utili per la gestione dei dati e verranno forniti i rudimenti per realizzare semplici funzioni. Verranno introdotti i tipi di file editabili in RStudio (script, markdown, \ldots). Nello specifico, dopo aver accennato alcune caratteristiche del sistema \texttt{tidyverse}, verranno illustrate le principali funzionalità dell'IDE RStudio e dei pacchetti \texttt{dplyr} e \texttt{ggplot2}. Sul web sono presenti tantissime introduzioni all'uso di R, per esempio \href{https://bookdown.org/hneth/ds4psy/}{questa}.

\hypertarget{prerequisiti}{%
\section{Prerequisiti}\label{prerequisiti}}

Al fine di utilizzare \texttt{R} è necessario eseguire le seguenti tre operazioni
nell'ordine dato:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Installare \texttt{R};
\item
  Installare RStudio;
\item
  Installare R-Packages (se necessario).
\end{enumerate}

Di seguito viene descritto come installare \texttt{R} e RStudio.

\hypertarget{installare-r-e-rstudio}{%
\subsection{Installare R e RStudio}\label{installare-r-e-rstudio}}

R è disponibile gratuitamente ed è scaricabile dal sito
\url{http://www.rproject.org/}. Dalla pagina principale del sito
\texttt{r-project.org} andiamo sulla sezione \texttt{Download} e scegliamo un server a
piacimento per scaricare il software d'installazione. Una volta
scaricato l'installer, lo installiamo come un qualsiasi software,
cliccando due volte sul file d'istallazione. Esistono versioni di R  per
tutti i più diffusi sistemi operativi (Windows, Mac OS X e Linux).

Il R Core Development Team lavora continuamente per migliorare le
prestazioni di R, per correggere errori e per consentire l'uso di   con
nuove tecnologie. Di conseguenza, periodicamente vengono rilasciate
nuove versioni di \texttt{R}. Informazioni a questo proposito sono fornite sulla
pagina web \url{https://www.r-project.org/}. Per installare una nuova
versione di \texttt{R} si segue la stessa procedura che è stata seguita per la
prima installazione.

Insieme al software si possono scaricare dal sito principale sia manuali d'uso che numerose dispense per approfondire diversi aspetti di \texttt{R}. In particolare, nel sito \url{http://cran.r-project.org/other-docs.html} si possono trovare anche numerose dispense in italiano (sezione ``Other languages'').

Dopo avere installato \texttt{R} è opportuno installare anche RStudio. RStudio si
può scaricare da \url{https://www.rstudio.com/}. Anche RStudio è disponibile
per tutti i più diffusi sistemi operativi.

\hypertarget{utilizzare-rstudio-per-semplificare-il-lavoro}{%
\subsection{Utilizzare RStudio per semplificare il lavoro}\label{utilizzare-rstudio-per-semplificare-il-lavoro}}

Possiamo pensare ad \texttt{R} come al motore di un automobile e a RStudio come
al cruscotto di un automobile. Più precisamente, \texttt{R} è un linguaggio di
programmazione che esegue calcoli mentre RStudio è un ambiente di
sviluppo integrato (IDE) che fornisce un'interfaccia grafica aggiungendo
una serie di strumenti che facilitano la fase di sviluppo e di
esecuzione del codice. Utilizzeremo dunque \texttt{R} mediante RStudio. In altre
parole,

\textbf{non aprite}

\includegraphics[width=0.15\textwidth,height=\textheight]{images/Rlogo.png}

\textbf{aprite invece}

\includegraphics[width=0.3\textwidth,height=\textheight]{images/RStudio-Logo-Blue-Gradient.png}

L'ambiente di lavoro di RStudio è costituito da quattro finestre: la finestra del codice (scrivere-eseguire script), la finestra della console (riga di comando -
output), la finestra degli oggetti (elenco oggetti-cronologia dei
comandi) e la finestra dei pacchetti-dei grafici-dell'aiuto in linea.

\begin{figure}
\hypertarget{fig:rstudio_pics}{%
\centering
\includegraphics[width=1\textwidth,height=\textheight]{images/rstudio_pics.png}
\caption{La console di RStudio.}\label{fig:rstudio_pics}
}
\end{figure}

\hypertarget{eseguire-il-codice}{%
\subsection{Eseguire il codice}\label{eseguire-il-codice}}

Mediante il menu a tendina di RStudio, scegliendo il percorso

\begin{verbatim}
File > New File > R Notebook
\end{verbatim}

oppure

\begin{verbatim}
File > New File > R Script
\end{verbatim}

l'utente può aprire nella finestra del codice (in alto a destra) un \texttt{R} Notebook o un \texttt{R} script dove inserire le istruzioni da eseguire.

In un R script, un blocco di codice viene eseguito selezionando un
insieme di righe di istruzioni e digitando la sequenza di tasti
\texttt{Command} + \texttt{Invio} sul Mac, oppure \texttt{Control} + \texttt{Invio} su Windows. In
un R Notebook, un blocco di codice viene eseguito schiacciando il
bottone con l'icona \(\color{red}\blacktriangleright\) (``Run current
chunk'') posizionata a destra rispetto al codice.

\hypertarget{chapter-sintassi}{%
\section{Sintassi di base}\label{chapter-sintassi}}

\texttt{R} è un linguaggio di programmazione orientato all'analisi dei dati, il
calcolo e la visualizzazione grafica. È disponibile su Internet una
vasta gamma di materiali utile per avvicinarsi all'ambiente \texttt{R} e aiutare
l'utente nell'apprendimento di questo software statistico. Cercheremo
qui di fornire alcune indicazioni e una breve descrizione delle risorse
di base di \texttt{R}.

Aggiungo qui sotto alcune considerazioni che ho preso, pari pari, da un testo che tratta di un altro linguaggio di programmazione, ma che si applicano perfettamente anche al caso nostro.

\begin{quote}
Come in ogni linguaggio, per parlare in R è necessario seguire un insieme di regole. Come in tutti i linguaggi di programmazione, queste regole sono del tutto inflessibili e inderogabili. In R, un enunciato o è sintatticamente corretto o è incomprensibile all'interprete, che lo segnalerà all'utente. Questo aspetto non è esattamente amichevole per chi non è abituato ai linguaggi di programmazione, e si trova così costretto ad una precisione di scrittura decisamente poco ``analogica''. Tuttavia, ci sono due aspetti positivi nello scrivere codice, interrelati tra loro. Il primo è lo sforzo analitico necessario, che allena ad un'analisi precisa del problema che si vuole risolvere in modo da poterlo formalizzare linguisticamente. Il secondo concerne una forma di autoconsapevolezza specifica: salvo ``bachi'' nel linguaggio (rarissimi sebbene possibili), il mantra del programmatore è ``Se qualcosa non ti funziona, è colpa tua'' (testo adattato da Andrea Valle).
\end{quote}

A chi preferisce un approccio più ``giocoso'' posso suggerire il seguente \href{https://tinystats.github.io/teacups-giraffes-and-statistics/01_introToR.html}{link}.

\hypertarget{utilizzare-la-console-r-come-calcolatrice}{%
\subsection{\texorpdfstring{Utilizzare la console \texttt{R} come calcolatrice}{Utilizzare la console R come calcolatrice}}\label{utilizzare-la-console-r-come-calcolatrice}}

La console di RStudio contiene un cursore rappresentato dal simbolo ``\textgreater{}''
(linea di comando) dove si possono inserire i comandi e le funzioni --
in realtà è sempre meglio utilizzare un \texttt{R} Notebook anziché la console,
ma per ora esaminiamo il funzionamento di quest'ultima.

La console di RStudio può essere utilizzata come semplice calcolatrice.
I comandi elementari consistono di espressioni o di assegnazioni. Le
operazioni aritmetiche vengono eseguite mediante simboli ``standard:'' +,
*, -, /, \texttt{sqrt()}, \texttt{log()}, \texttt{exp()}, \ldots{}

I comandi sono separati da un carattere di nuova linea (si immette un
carattere di nuova linea digitando il tasto \texttt{Invio}). Se un comando non
è completo alla fine della linea, \texttt{R} darà un prompt differente che per
default è il carattere \texttt{+} sulla linea seguente e continuerà a leggere
l'input finché il comando non è sintatticamente completo. Ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{4} \SpecialCharTok{{-}}
  \SpecialCharTok{+}
    \SpecialCharTok{+}\DecValTok{1}
\CommentTok{\#\textgreater{} [1] 3}
\end{Highlighting}
\end{Shaded}

\texttt{R} è un ambiente interattivo, ossia i comandi producono una risposta immediata. Se scriviamo \texttt{2\ +\ 2} e premiamo il tasto di invio, comparirà nella riga successiva il risultato:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \SpecialCharTok{+} \DecValTok{2}
\CommentTok{\#\textgreater{} [1] 4}
\end{Highlighting}
\end{Shaded}

Il risultato è preceduto da \texttt{{[}1{]}}, il che significa che il risultato dell'operazione che abbiamo appena eseguito è il primo valore di questa linea. Alcune funzioni ritornano più di un singolo numero e, in quel caso, l'informazione fornita da \texttt{R} è più utile. Per esempio, l'istruzione \texttt{100:130} ritorna \(31\) valori, ovvero i numeri da \(100\) a \(130\):

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{100}\SpecialCharTok{:}\DecValTok{130}
\CommentTok{\#\textgreater{}  [1] 100 101 102 103 104 105 106 107 108 109 110 111 112 113}
\CommentTok{\#\textgreater{} [15] 114 115 116 117 118 119 120 121 122 123 124 125 126 127}
\CommentTok{\#\textgreater{} [29] 128 129 130}
\end{Highlighting}
\end{Shaded}

In questo caso, sul mio computer, \texttt{{[}24{]}} indica che il valore \(123\) è il ventiquattresimo numero che è stato stampato sulla console -- su un altro computer le cose possono essere diverse in quanto il risultato, credo, dipende dalla grandezza dello schermo.

\hypertarget{espressioni}{%
\subsection{Espressioni}\label{espressioni}}

In questo corso, cercheremo di evitare i numeri nei nomi R, così come le lettere maiuscole e .. Useremo quindi nomi come: my\_data, anova\_results, square\_root, ecc.

Un'espressione in \texttt{R} è un enunciato finito e autonomo del linguaggio: una frase conclusa, si potrebbe dire. Si noti che le espressioni in \texttt{R} non sono delimitate dal \texttt{;} come succede in alcuni linguaggi di programmazione. L'ordine delle espressioni è l'ordine di esecuzione delle stesse.

L'a capo non è rilevante per \texttt{R}. Questo permette di utilizzare l'a capo per migliorare la leggibilità del codice.

\hypertarget{oggetti}{%
\subsection{Oggetti}\label{oggetti}}

\texttt{R} è un linguaggio di programmazione a oggetti, quindi si basa sulla creazione di oggetti e sulla possibilità di salvarli nella memoria del programma. \texttt{R} distingue tra maiuscole e minuscole come la maggior parte dei linguaggi basati su UNIX, quindi \texttt{A} e \texttt{a} sono nomi diversi e fanno riferimento a oggetti diversi.

I comandi elementari di \texttt{R} consistono in espressioni o assegnazioni.

Se un'espressione viene fornita come comando, viene valutata, stampata sullo schermo e il valore viene perso, come succedeva alle operazioni aritmetiche che abbiamo presentato sopra discutendo l'uso della console \texttt{R} come calcolatrice.

Un'assegnazione crea un oggetto oppure valuta un'espressione e passa il valore a un oggetto, ma il risultato non viene stampato automaticamente sullo schermo. Per l'operazione di assegnazione si usa il simbolo \texttt{\textless{}-}. Ad esempio, per creare un oggetto che contiene il risultato dell'operazione \texttt{2\ +\ 2} procediamo nel modo seguente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res\_sum }\OtherTok{\textless{}{-}} \DecValTok{2} \SpecialCharTok{+} \DecValTok{2}
\NormalTok{res\_sum}
\CommentTok{\#\textgreater{} [1] 4}
\end{Highlighting}
\end{Shaded}

L'operazione di assegnazione (\texttt{\textless{}-}) copia il contenuto dell'operando destro (detto \texttt{r-value}) nell'operando sinistro detto (\texttt{l-value}). Il valore dell'espressione assegnazione è \texttt{r-value}. Nell'esempio precedente, \texttt{res\_sum} (\texttt{l-value}) assume il valore di \(4\).

\hypertarget{variabili}{%
\subsection{Variabili}\label{variabili}}

L'oggetto \texttt{res\_sum} è una \emph{variabile}. Una spiegazione di ciò che questo significa è riportata qui sotto.

\begin{quote}
Una variabile è un segnaposto. Tutte le volte che si memorizza un dato lo si assegna ad una variabile. Infatti, se il dato è nella memoria, per potervi accedere, è necessario conoscere il suo indirizzo, la sua ``etichetta'' (come in un grande magazzino in cui si va a cercare un oggetto in base alla sua collocazione). Se il dato è memorizzato ma inaccessibile (come nel caso di un oggetto sperso in un magazzino), allora non si può usare ed è soltanto uno spreco di spazio. La teoria delle variabili è un ambito molto complesso nella scienza della computazione. Ad esempio, una aspetto importante può concernere la tipizzazione delle variabili. Nei linguaggi ``tipizzati'' (ad esempio C), l'utente dichiara che userà quella etichetta (la variabile) per contenere solo ed esclusivamente un certo tipo di oggetto (ad esempio, un numero intero), e la variabile non potrà essere utilizzata per oggetti diversi (ad esempio, una stringa). In questo caso, prima di usare una variabile se ne dichiara l'esistenza e se ne specifica il tipo. I linguaggi non tipizzati non richiedono all'utente di specificare il tipo, che viene inferito in vario modo (ad esempio, in funzione dell'assegnazione del valore alla variabile). Alcuni linguaggi (ad esempio Python) non richiedono neppure la dichiarazione della variabile, che viene semplicemente usata. È l'interprete che inferisce che quella stringa è una variabile. La tipizzazione impone vincoli d'uso sulle variabili e maggiore scrittura del codice, ma assicura una chiara organizzazione dei dati. In assenza di tipizzazione, si lavora in maniera più rapida e snella, ma potenzialmente si può andare incontro a situazioni complicate, come quando si cambia il tipo di una variabile ``in corsa'' senza accorgersene (Andrea Valle).
\end{quote}

\texttt{R} è un linguaggio non tipicizzato, come Python. In \texttt{R} non è necessario dichiarare le variabili che si intendono utilizzare, né il loro tipo.

\hypertarget{r-console}{%
\subsection{R console}\label{r-console}}

La console di RStudio fornisce la possibilità di richiamare e rieseguire
i comandi. I tasti freccia verticale, \(\uparrow\) e \(\downarrow\), sulla
tastiera possono essere utilizzati per scorrere avanti e indietro i
comandi già immessi. Appena trovato il comando che interessa, lo si può
modificare, ad esempio, con i tasti freccia orizzontali, immettendo
nuovi caratteri o cancellandone altri.

Se viene digitato un comando che \texttt{R} non riconosce, sulla console viene visualizzato un messaggio di errore; ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3}\NormalTok{ \% }\DecValTok{9}
\NormalTok{Errore}\SpecialCharTok{:}\NormalTok{ unexpected input }\ControlFlowTok{in} \StringTok{"3 \% 9"}
\end{Highlighting}
\end{Shaded}

\hypertarget{parentesi}{%
\subsection{Parentesi}\label{parentesi}}

Le parentesi in \texttt{R} (come in generale in ogni linguaggio di programmazione) assegnano un significato diverso alle porzioni di codice che delimitano.

\begin{itemize}
\tightlist
\item
  Le parentesi tonde funzionano come nell'algebra. Per esempio
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \SpecialCharTok{+} \DecValTok{3} \SpecialCharTok{*} \DecValTok{4}
\CommentTok{\#\textgreater{} [1] 14}
\end{Highlighting}
\end{Shaded}

non è equivalente a

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{2} \SpecialCharTok{+} \DecValTok{3}\NormalTok{) }\SpecialCharTok{*} \DecValTok{4}
\CommentTok{\#\textgreater{} [1] 20}
\end{Highlighting}
\end{Shaded}

Le due istruzioni precedenti producono risultati diversi perché, se
la sequenza delle operazioni algebriche non viene specificata dalle
parentesi, \texttt{R} assegna alle operazioni algebriche il seguente ordine
di priorità decrescente: esponenziazione, moltiplicazione /
divisione, addizione / sottrazione, confronti logici
(\texttt{\textless{},\ \textgreater{},\ \textless{}=,\ \textgreater{}=,\ ==,\ !=}). È sempre una buona idea rendere esplicito
l'ordine delle operazioni algebriche che si vuole eseguire mediante
l'uso delle parentesi tonde.\\
Le parentesi tonde vengono anche utilizzate per le funzioni, come
vedremo nei prossimi paragrafi. Tra le parentesi tonde avremo dunque
l'oggetto a cui vogliamo applicare la funzione e gli argomenti
passati alla funzione.

\begin{itemize}
\item
  Le parentesi graffe sono destinate alla programmazione. Un blocco
  tra le parentesi graffe viene letto come un oggetto unico che può
  contenere una o più istruzioni.
\item
  Le parentesi quadre vengono utilizzate per selezionare degli
  elementi, per esempio all'interno di un vettore, o di una matrice, o
  di un data.frame. L'argomento entro le parentesi quadre può essere
  generato da espressioni logiche.
\end{itemize}

\hypertarget{i-nomi-degli-oggetti}{%
\subsection{I nomi degli oggetti}\label{i-nomi-degli-oggetti}}

Le entità create e manipolate da \texttt{R} si chiamano `oggetti'. Tali oggetti
possono essere variabili (come nell'esempio che abbiamo visto sopra), array di numeri, caratteri, stringhe, funzioni, o più in generale strutture costruite a partire da tali
componenti. Durante una sessione di R gli oggetti sono creati e
memorizzati attraverso opportuni nomi.

I nomi possono contenere un qualunque carattere alfanumerico e come
carattere speciale il trattino basso (\texttt{\_}) o il punto. R fornisce i
seguenti vincoli per i nomi degli oggetti: i nomi degli oggetti non
possono mai iniziare con un carattere numerico e non possono contenere i
seguenti simboli: \texttt{\$}, \texttt{@}, \texttt{!}, \texttt{\^{}}, \texttt{+}, \texttt{-}, \texttt{/}, \texttt{*}. È buona
pratica usare nomi come \texttt{ratio\_of\_sums}. È fortemente sconsigliato
utilizzare nei nomi degli oggetti caratteri accentati o, ancora peggio,
apostrofi. Per questa ragione è sensato creare i nomi degli oggetti
utilizzando la lingua inglese. È anche bene che i nomi degli oggetti non
coincidano con nomi di funzioni. Ricordo nuovamente che \texttt{R} è \emph{case sensitive}, cioè
\texttt{A} e \texttt{a} sono due simboli diversi e identificano due oggetti
differenti.

In questo corso cercheremo di evitare i numeri nei nomi degli oggetti \texttt{R}, così come le lettere maiuscole e il punto. Useremo quindi nomi come: \texttt{my\_data}, \texttt{regression\_results}, \texttt{square\_root}, ecc.

\hypertarget{permanenza-dei-dati-e-rimozione-di-oggetti}{%
\subsection{Permanenza dei dati e rimozione di oggetti}\label{permanenza-dei-dati-e-rimozione-di-oggetti}}

Gli oggetti vengono salvati nello ``spazio di lavoro'' (\emph{workspace}). Il
comando \texttt{ls()} può essere utilizzato per visualizzare i nomi degli
oggetti che sono in quel momento memorizzati in \texttt{R}.

Per eliminare oggetti dallo spazio di lavoro è disponibile la funzione
\texttt{rm()}; ad esempio

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rm}\NormalTok{(x, y, z, ink, junk, temp, foo, bar)}
\end{Highlighting}
\end{Shaded}

cancella tutti gli oggetti indicati entro parentesi. Per eliminare tutti
gli oggetti presenti nello spazio di lavoro si può utilizzare la
seguente istruzione:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rm}\NormalTok{(}\AttributeTok{list =} \FunctionTok{ls}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\hypertarget{chiudere-r}{%
\subsection{Chiudere R}\label{chiudere-r}}

Quando si chiude RStudio il programma ci chiederà se si desidera salvare
l'area di lavoro sul computer. Tale operazione è da evitare in quanto
gli oggetti così salvati andranno ad interferire con gli oggetti creati
in un lavoro futuro. Si consiglia dunque di rispondere negativamente a
questa domanda.

\begin{itemize}
\item
  In RStudio, selezionare \texttt{Preferences} dal menu a tendina e, in
  \texttt{R\ General} \texttt{Workspace}, deselezionare l'opzione
  \texttt{Restore\ .RData\ into\ workspace\ at\ start-} \texttt{up} e scegliere l'opzione
  \texttt{Never} nella finestra di dialogo \texttt{Save\ workspace\ to}
  \texttt{.RData\ on\ exit}.
\item
  In R, selezionare \texttt{Preferences} dal menu a tendina e, in \texttt{Startup},
  selezionare l'opzione \texttt{No} in corrispondenza dell'item
  \texttt{Save\ workspace\ on\ exit\ from\ R}.
\end{itemize}

\hypertarget{creare-ed-eseguire-uno-script-r-con-un-editore}{%
\subsection{Creare ed eseguire uno script R con un editore}\label{creare-ed-eseguire-uno-script-r-con-un-editore}}

È molto più facile interagire con R manipolando uno script con un
editore piuttosto che inserendo direttamente le istruzioni nella
console. \texttt{R} fornisce il Text Editor dove è possibile inserire il codice
(File \(\to\) New Script). Per salvare il file basta utilizzare l'apposito
menù a tendina (estensione \texttt{.R}). Tale file potrà poi essere riaperto ed
utilizzato in un momento successivo.

L'editore comunica con \texttt{R} nel modo seguente: dopo avere selezionato la
porzione di codice che si vuole eseguire, si digita un'apposita sequenza
di tasti (\texttt{Command\ +\ Enter} su Mac OS X e \texttt{ctrl\ +\ r} in Windows).
\texttt{ctrl\ +\ r} significa premere il tasto \texttt{ctrl} e, tenendolo premuto, premere il tasto \texttt{r} della tastiera.
Così facendo, \texttt{R} eseguirà le istruzioni selezionate e l'output verrà
stampato sulla console. Il Text Editor fornito da \texttt{R} è piuttosto
primitivo: è fortemente consigliato utilizzare RStudio.

\hypertarget{commentare-il-codice}{%
\subsection{Commentare il codice}\label{commentare-il-codice}}

Un ``commento'' è una parte di codice che l'interprete non tiene in considerazione. Quando l'interprete arriva ad un segnalatore di commento salta fino al segnalatore di fine commento e di lì riprende il normale processo esecutivo.

I commenti sono parole in linguaggio naturale (nel nostro caso l'italiano), che permettono agli utilizzatori di capire il flusso logico del codice e a chi lo ha scritto di ricordare il perché di determinate istruzioni.

In \texttt{R}, le parole dopo il simbolo \texttt{\#} sono considerate commenti e sono ignorate; ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Questo e\textquotesingle{} un commento}
\end{Highlighting}
\end{Shaded}

\hypertarget{cambiare-la-cartella-di-lavoro}{%
\subsection{Cambiare la cartella di lavoro}\label{cambiare-la-cartella-di-lavoro}}

Quando si inizia una sessione di lavoro, \texttt{R} sceglie una cartella quale
``working directory''. Sarà in tale cartella che andrà a cercare gli
script definiti dall'utilizzatore e i file dei dati. È possibile
determinare quale sia la corrente ``working directory'' digitando sulla
console di RStudio l'istruzione:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{getwd}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

Per cambiare la cartella di lavoro (in maniera tale che corrisponda alla
cartella nella quale sono stati salvati i dati e gli script da eseguire)
si sceglie la voce \texttt{Set\ Working\ Directory} sul menù a tendina di RStudio
e si selezione la voce \texttt{Choose\ Directory\ldots{}} Nella finestra che compare,
si cambia la cartella con quella che si vuole.

\hypertarget{loggetto-base-di-r-il-vettore}{%
\subsection{L'oggetto base di R: il vettore}\label{loggetto-base-di-r-il-vettore}}

\texttt{R} opera su strutture di dati; la più semplice di tali strutture è il
vettore numerico, che consiste in un insieme ordinato di numeri; ad
esempio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\FloatTok{7.0}\NormalTok{, }\FloatTok{10.2}\NormalTok{, }\SpecialCharTok{{-}}\FloatTok{2.9}\NormalTok{, }\FloatTok{21.4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Nell'istruzione precedente, \texttt{c()} è una funzione. In R gli argomenti
sono passati alle funzioni inserendoli all'interno delle parentesi
tonde. Si noti che gli argomenti (in questo caso, i numeri
\(7.0, 10.2, -2.9, 21.4\)) sono separati a virgole. La funzione \texttt{c()} può
prendere un numero arbitrario di argomenti e genera un vettore
concatenando i suoi argomenti. L'operatore \texttt{\textless{}-} assegna un nome al
vettore che è stato creato. Nel caso presente, digitando \texttt{x} possiamo
visualizzare il vettore che abbiamo creato:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\CommentTok{\#\textgreater{} [1]  7.0 10.2 {-}2.9 21.4}
\end{Highlighting}
\end{Shaded}

Se invece eseguiamo l'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{c}\NormalTok{(}\FloatTok{7.0}\NormalTok{, }\FloatTok{10.2}\NormalTok{, }\SpecialCharTok{{-}}\FloatTok{2.9}\NormalTok{, }\FloatTok{21.4}\NormalTok{)}
\CommentTok{\#\textgreater{} [1]  7.0 10.2 {-}2.9 21.4}
\end{Highlighting}
\end{Shaded}

senza assegnazione, il valore dell'espressione sarà visualizzato nella
console, ma il vettore non potrà essere utilizzato in nessun altro modo.

\hypertarget{operazioni-vettorializzate}{%
\subsection{Operazioni vettorializzate}\label{operazioni-vettorializzate}}

Molte operazioni in \texttt{R} sono vettorializzate, il che significa che esse
sono eseguite in parallelo in determinati oggetti. Ciò consente di
scrivere codice che sia efficiente, conciso e più facile da leggere
rispetto al codice che contiene istruzioni non vettorializzate.

\hypertarget{vettori-aritmetici}{%
\subsection{Vettori aritmetici}\label{vettori-aritmetici}}

L'esempio più semplice che illustra come si svolgono le operazioni
vettorializzate riguarda le operazioni algebriche applicate ai vettori.
I vettori, infatti, possono essere utilizzati in espressioni numeriche
nelle quali le operazioni algebriche vengono eseguite ``elemento per
elemento''.

Per illustrare questo concetto, definiamo il vettore \texttt{die} che contiene
i possibili risultati del lancio di un dado:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\NormalTok{die}
\CommentTok{\#\textgreater{} [1] 1 2 3 4 5 6}
\end{Highlighting}
\end{Shaded}

Supponiamo di volere sommare \(10\) a ciascun elemento del vettore \texttt{die}.
Dato che le operazioni sui vettori sono eseguite elemento per elemento,
per ottenere questo risultato è sufficiente eseguire l'istruzione:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\SpecialCharTok{+} \DecValTok{10}
\CommentTok{\#\textgreater{} [1] 11 12 13 14 15 16}
\end{Highlighting}
\end{Shaded}

Si noti come la costante \(10\) sia stata sommata a ciascun elemento del
vettore. In maniera corrispondente, l'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\SpecialCharTok{{-}} \DecValTok{1}
\CommentTok{\#\textgreater{} [1] 0 1 2 3 4 5}
\end{Highlighting}
\end{Shaded}

sottrarrà un'unità da ciascuno degli elementi del vettore \texttt{die}.

Se l'operazione aritmetica coinvolge due o più vettori, R allinea i vettori ed esegue una sequenza di operazioni elemento per elemento. Per esempio, l'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die }\SpecialCharTok{*}\NormalTok{ die}
\CommentTok{\#\textgreater{} [1]  1  4  9 16 25 36}
\end{Highlighting}
\end{Shaded}

fa sì che i due vettori vengano disposti l'uno di fianco all'altro per poi moltiplicare gli elementi corrispondenti: il primo elemento del primo vettore per il primo elemento del secondo vettore e così via. Il vettore risultante avrà la stessa dimensione dei due vettori che sono stati moltiplicati, come indicato qui sotto:

\[
\begin{array}{ccccc}
1 & \times & 1 & \to & 1 \\
2 & \times & 2 & \to & 4 \\
3 & \times & 3 & \to & 9 \\
4 & \times & 4 & \to & 16 \\
5 & \times & 5 & \to & 25 \\
6 & \times & 6 & \to & 36 \\
\hline
\verb+die+ & * & \verb+die+ & = & 
\end{array}
\]
Oltre agli operatori aritmetici elementari \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, e \texttt{\^{}} per
l'elevamento a potenza, sono disponibili le più comuni funzioni
matematiche: \texttt{log()}, \texttt{exp()}, \texttt{sin()}, \texttt{cos()}, \texttt{tan()}, \texttt{sqrt()},
\texttt{max()}, \texttt{min()} e così via. Altre funzioni di uso comune sono:
\texttt{range()} che restituisce un vettore \texttt{c(min(x),\ max(x))}; \texttt{sort()} che
restituisce un vettore ordinato; \texttt{length(x)} che restituisce il numero
di elementi di \texttt{x}; \texttt{sum(x)} che dà la somma degli elementi di \texttt{x},
mentre \texttt{prod(x)} dà il loro prodotto. Due funzioni statistiche di uso
comune sono \texttt{mean(x)}, la media aritmetica, e \texttt{var(x)}, la varianza.

\hypertarget{generazione-di-sequenze-regolari}{%
\subsection{Generazione di sequenze regolari}\label{generazione-di-sequenze-regolari}}

\texttt{R} possiede un ampio numero di funzioni per generare sequenze di numeri.
Ad esempio, \texttt{c(1:10)} è il vettore \texttt{c(1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8,\ 9,\ 10)}.
L'espressione \texttt{c(30:1)} può essere utilizzata per generare una sequenza
all'indietro.

La funzione \texttt{seq()} genera un vettore che contiene una sequenza regolare
di numeri, generata in base a determinate regole. Può avere 5 argomenti:
i primi due rappresentano l'inizio (\texttt{from}) e la fine (\texttt{to}) della
sequenza, il terzo specifica l'ampiezza del passo (\texttt{by}), il quarto la
lunghezza della sequenza (\texttt{length.out}) e infine il quinto
(\texttt{along.with}), che se utilizzato deve essere l'unico parametro
presente, è il nome di un vettore, ad esempio \texttt{x}, creando in tal modo
la sequenza 1, 2, \ldots, \texttt{length(x)}. Esempi di utilizzo della funzione
\texttt{seq()} sono i seguenti:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{seq}\NormalTok{(}\AttributeTok{from =} \DecValTok{1}\NormalTok{, }\AttributeTok{to =} \DecValTok{10}\NormalTok{)}
\CommentTok{\#\textgreater{}  [1]  1  2  3  4  5  6  7  8  9 10}
\FunctionTok{seq}\NormalTok{(}\SpecialCharTok{{-}}\DecValTok{5}\NormalTok{, }\DecValTok{5}\NormalTok{, }\AttributeTok{by =} \FloatTok{2.5}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] {-}5.0 {-}2.5  0.0  2.5  5.0}
\FunctionTok{seq}\NormalTok{(}\AttributeTok{from =} \DecValTok{1}\NormalTok{, }\AttributeTok{to =} \DecValTok{7}\NormalTok{, }\AttributeTok{length.out =} \DecValTok{4}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 1 3 5 7}
\FunctionTok{seq}\NormalTok{(}\AttributeTok{along.with =}\NormalTok{ die)}
\CommentTok{\#\textgreater{} [1] 1 2 3 4 5 6}
\end{Highlighting}
\end{Shaded}

Altra funzione utilizzata per generare sequenze è \texttt{rep()} che può essere
utilizzata per replicare un oggetto in vari modi. Ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{die3 }\OtherTok{\textless{}{-}} \FunctionTok{rep}\NormalTok{(die, }\AttributeTok{times =} \DecValTok{3}\NormalTok{)}
\NormalTok{die3}
\CommentTok{\#\textgreater{}  [1] 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6}
\end{Highlighting}
\end{Shaded}

metterà tre copie di \texttt{die} nell'oggetto \texttt{die3}.

\hypertarget{generazione-di-numeri-casuali}{%
\subsection{Generazione di numeri casuali}\label{generazione-di-numeri-casuali}}

La funzione \texttt{sample()} è una delle tante funzioni che possono essere
usate per generare numeri casuali. Per esempio, la seguente istruzione
simula dieci lanci di un dado a sei facce:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roll }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{6}\NormalTok{, }\DecValTok{10}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{roll}
\CommentTok{\#\textgreater{}  [1] 1 5 1 1 2 4 2 2 1 4}
\end{Highlighting}
\end{Shaded}

Il primo argomento di \texttt{sample()} è il vettore da cui la funzione
estrarrà degli elementi a caso; il secondo argomento specifica che
dovranno essere effettuate 10 estrazioni casuali; il terzo argomento
specifica che le estrazioni sono con rimessa (cioè, lo stesso elemento
può essere estratto più di una volta).

Scegliere un elemento a caso dal vettore \(\{1, 2, 3, 4, 5, 6\}\) è
equivalente a lanciare un dado e osservare la faccia che si presenta.
L'istruzione precedente corrisponde dunque alla simulazione di dieci
lanci di un dado a sei facce.

\hypertarget{vettori-logici}{%
\subsection{Vettori logici}\label{vettori-logici}}

Quando si manipolano i vettori, talvolta si vogliono trovare gli
elementi che soddisfano determinate condizioni logiche. Per esempio, in
dieci lanci di un dado, quante volte è uscito \(5\)? Per rispondere a
questa domanda si possono usare gli operatori logici \texttt{\textless{}}, \texttt{\textgreater{}} e \texttt{==} per
le operazioni di ``minore di,'' ``maggiore di'' e ``uguale a''. Se scriviamo

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roll }\SpecialCharTok{==} \DecValTok{5}
\CommentTok{\#\textgreater{}  [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE}
\CommentTok{\#\textgreater{} [10] FALSE}
\end{Highlighting}
\end{Shaded}

creiamo un vettore costituito da elementi \texttt{TRUE/FALSE} i quali
identificano gli elementi del vettore che soddisfano la condizione
logica specificata.

Possiamo trattare tale vettore come se fosse costituito da elementi di
valore \(0\) e \(1\). Sommando gli elementi di tale vettore, infatti,
possiamo contare il numero di ``5'':

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(roll }\SpecialCharTok{==} \DecValTok{5}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 1}
\end{Highlighting}
\end{Shaded}

\hypertarget{dati-mancanti}{%
\subsection{Dati mancanti}\label{dati-mancanti}}

Quando si è in presenza di un dato mancante, R assegna il valore
speciale \texttt{NA}, che sta per \emph{Not Available}. In generale, un'operazione
su un \texttt{NA} dà come risultato un \texttt{NA}. Nell'uso delle funzioni che
operano sui dati sarà dunque necessario specificare che, qualunque
operazione venga effettuata, gli \texttt{NA} devono essere esclusi.

\hypertarget{vettori-di-caratteri-e-fattori}{%
\subsection{Vettori di caratteri e fattori}\label{vettori-di-caratteri-e-fattori}}

I vettori di caratteri si creano formando una sequenza di caratteri
delimitati da doppie virgolette e possono essere concatenati in un
vettore attraverso la funzione \texttt{c()}. Successivamente, si può applicare
la funzione \texttt{factor()}, che definisce automaticamente le modalità della
variabile categoriale. Ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{soc\_status }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(}
  \FunctionTok{c}\NormalTok{(}\StringTok{"low"}\NormalTok{, }\StringTok{"high"}\NormalTok{, }\StringTok{"medium"}\NormalTok{, }\StringTok{"high"}\NormalTok{, }\StringTok{"low"}\NormalTok{, }\StringTok{"medium"}\NormalTok{, }\StringTok{"high"}\NormalTok{)}
\NormalTok{)}
\FunctionTok{levels}\NormalTok{(soc\_status)}
\CommentTok{\#\textgreater{} [1] "high"   "low"    "medium"}
\end{Highlighting}
\end{Shaded}

Talvolta l'ordine dei livelli del fattore non importa, mentre altre
volte l'ordine è importante, per esempio, quando una variable
categoriale viene rappresentata in un grafico. Per specificare l'ordine
dei livelli del fattore si usa la seguente sintassi:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{soc\_status }\OtherTok{\textless{}{-}}
  \FunctionTok{factor}\NormalTok{(soc\_status, }\AttributeTok{levels =} \FunctionTok{c}\NormalTok{(}\StringTok{"low"}\NormalTok{, }\StringTok{"medium"}\NormalTok{, }\StringTok{"high"}\NormalTok{))}
\FunctionTok{levels}\NormalTok{(soc\_status)}
\CommentTok{\#\textgreater{} [1] "low"    "medium" "high"}
\end{Highlighting}
\end{Shaded}

\hypertarget{funzioni}{%
\subsection{Funzioni}\label{funzioni}}

\texttt{R} offre la possibilità di utilizzare un'enorme libreria di funzioni che
permettono di svolgere operazioni complicate, quali ad esempio, il
campionamento casuale. Esaminiamo ora con più attenzione le proprietà
delle funzioni di \texttt{R} utilizzando ancora l'esempio del lancio di un dado.
Abbiamo visto in precedenza come il lancio di un dado possa essere
simulato da R con la funzione \texttt{sample()}. La funzione \texttt{sample()} prende
tre argomenti: il nome di un vettore, un numero chiamato \texttt{size} e un
argomento chiamato \texttt{replace}. La funzione \texttt{sample()} ritorna un numero
di elementi del vettore pari a \texttt{size}. Ad esempio

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(die, }\DecValTok{2}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 1 5}
\end{Highlighting}
\end{Shaded}

Assegnando \texttt{TRUE} all'argomento \texttt{replace} specifichiamo che vogliamo un
campionamento con rimessa.

Se volgiamo eseguire una serie di lanci indipendenti di un dado,
eseguiamo ripetutamente la funzione \texttt{sample()} ponendo \texttt{size} uguale a
1:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(die, }\DecValTok{1}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 6}
\FunctionTok{sample}\NormalTok{(die, }\DecValTok{1}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 4}
\FunctionTok{sample}\NormalTok{(die, }\DecValTok{1}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{} [1] 2}
\end{Highlighting}
\end{Shaded}

Come si fa a sapere quanti e quali argomenti sono richiesti da una
funzione? Tale informazione viene fornita dalla funzione \texttt{args()}. Nel
nostro caso

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{args}\NormalTok{(sample)}
\CommentTok{\#\textgreater{} function (x, size, replace = FALSE, prob = NULL) }
\CommentTok{\#\textgreater{} NULL}
\end{Highlighting}
\end{Shaded}

ci informa che il primo argomento è un vettore chiamato \texttt{x}, il secondo
argomento è chiamato \texttt{size} ed ha il significato descritto sopra, il
terzo argomento, \texttt{replace}, specifica se il campionamento è eseguito con
o senza reimmissione, e il quarto argomento, \texttt{prob}, assegna delle
probabilità agli elementi del vettore. Il significato degli argomenti
viene spiegato nel file di help della funzione. Si noti che agli ultimi
due argomenti sono stati assegnati dei valori, detti di default. Ciò
significa che, se l'utilizzatore non li cambia, verranno usati da . La
specificazione \texttt{replace\ =\ FALSE} significa che il campionamento viene
eseguito senza reimmissione. Se desideriamo un campionamento con
reimmissione, basta specificare \texttt{replace\ =\ TRUE} (nel caso di una
singola estrazione è ovviamente irrilevante). Ad esempio, l'istruzione
seguente simula i risultati di 10 lanci indipendenti di un dado:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sample}\NormalTok{(die, }\DecValTok{10}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\CommentTok{\#\textgreater{}  [1] 2 3 1 1 3 4 5 5 5 4}
\end{Highlighting}
\end{Shaded}

Infine, \texttt{prob\ =\ NULL} specifica che non viene alterata la probabilità di
estrazione degli elementi del vettore. In generale, gli argomenti di una
funzione possono essere oggetti come vettori, matrici, altre funzioni,
parametri o operatori logici.

\texttt{R} ha un sistema di help interno in formato HTML che si richiama con
\texttt{help.start()}. Per avere informazioni su qualche funzione specifica,
per esempio la funzione \texttt{sample()}, il comando da utilizzare è
\texttt{help(sample)} oppure \texttt{?sample}.

\hypertarget{scrivere-proprie-funzioni}{%
\subsection{Scrivere proprie funzioni}\label{scrivere-proprie-funzioni}}

Abbiamo visto in precedenza come sia possibile simulare i risultati
prodotti da dieci lanci di un dado o, in maniera equivalente, dal
singolo lancio di dieci dadi. Possiamo replicare questo processo
digitando ripetutamente le stesse istruzioni nella console. Otterremo
ogni volta risultati diversi perché, ad ogni ripetizione, il generatore
di numeri pseudo-casuali di R dipende dal valore ottenuto dal clock
interno della macchina. La funzione \texttt{set.seed()} ci permette di
replicare esattamente i risultati della generazione di numeri casuali.
Per ottenere questo risultato, basta assegnare al seed un numero
arbitrario, es. \texttt{set.seed(12345)}. Tuttavia, questa procedura è
praticamente difficile da perseguire se il numero di ripetizioni è alto.
In tal caso è vantaggioso scrivere una funzione contenente il codice che
specifica il numero di ripetizioni. In questo modo, per trovare il
risultato cercato basterà chiamare la funzione una sola volta.

Le funzioni utilizzate da \texttt{R} sono costituite da tre elementi: il nome, il blocco del
codice e una serie di argomenti. Per creare una funzione è necessario
immagazzinare in R questi tre elementi e \texttt{function()} consente di
ottenere tale risultato usando la sintassi seguente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nome\_funzione }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(arg1, arg2, ...) \{}
\NormalTok{  espressione1}
\NormalTok{  espressione2}
  \FunctionTok{return}\NormalTok{(risultato)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Una chiamata di funzione è poi eseguita nel seguente modo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{nome\_funzione}\NormalTok{(arg1, arg2, ...)}
\end{Highlighting}
\end{Shaded}

Per potere essere utilizzata, una funzione deve essere presente nella
memoria di lavoro di \texttt{R}. Le funzioni salvate in un file possono essere
richiamate utilizzando la funzione \texttt{source()}, ad esempio,
\texttt{source("file\_funzioni.R")}.

Consideriamo ora la funzione \texttt{two\_rolls()} che ritorna la somma dei
punti prodotti dal lancio di due dadi non truccati:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{two\_rolls }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  die }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{6}
\NormalTok{  res }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(die, }\AttributeTok{size =} \DecValTok{2}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{  sum\_res }\OtherTok{\textless{}{-}} \FunctionTok{sum}\NormalTok{(res)}
  \FunctionTok{return}\NormalTok{(sum\_res)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

La funzione \texttt{two\_rolls()} inizia con il creare il vettore \texttt{die} che
contiene sei elementi: i numeri da \(1\) a \(6\). Viene poi utilizzata la
funzione \texttt{sample()} con gli gli argomenti, \texttt{die}, \texttt{size\ =\ 2} e
\texttt{replace\ =\ TRUE}. Tale funzione restituisce il risultato del lancio di
due dadi. Il risultato fornito da \texttt{sample(die,\ size\ =\ 2,\ replace\ =\ TRUE)} viene assegnato all'oggetto \texttt{res}. L'oggetto \texttt{res} corrisponde dunque ad un vettore di due elementi.
L'istruzione \texttt{sum(res)} somma gli elementi del vettore \texttt{res} e
attribuisce il risultato di questa operazione a \texttt{sum\_res}. Infine, la
funzione \texttt{return()} ritorna il contenuto dell'oggetto \texttt{sum\_res}.
Invocando la funzione \texttt{two\_rolls()} si ottiene dunque la somma del
lancio di due dadi. In generale, la funzione \texttt{two\_rolls()} produrrà un
risultato diverso ogni volta che viene usata:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{two\_rolls}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] 6}
\FunctionTok{two\_rolls}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] 5}
\FunctionTok{two\_rolls}\NormalTok{()}
\CommentTok{\#\textgreater{} [1] 3}
\end{Highlighting}
\end{Shaded}

La formattazione del codice mediante l'uso di spazi e rientri non è
necessaria ma è altamente raccomandata per minimizzare la probabilità di
compiere errori.

\hypertarget{pacchetti}{%
\subsection{Pacchetti}\label{pacchetti}}

Le funzioni di \texttt{R} sono organizzate in pacchetti, i più importanti dei
quali sono già disponibili quando si accede al programma.

\hypertarget{istallazione-e-upgrade-dei-pacchetti}{%
\subsection{Istallazione e upgrade dei pacchetti}\label{istallazione-e-upgrade-dei-pacchetti}}

Alcuni pacchetti non sono presenti nella release di base di \texttt{R}. Per
installare un pacchetto non presente è sufficiente scrivere nella
console:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"nome\_pacchetto"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

La prima volta che si usa questa funzione durante una sessione di lavoro
si dovrà anche selezionare da una lista il sito \emph{mirror} da cui
scaricare il pacchetto.

Gli autori dei pacchetti periodicamente rilasciano nuove versioni dei
loro pacchetti che contengono miglioramenti di varia natura. Per
eseguire l'upgrade dei pacchetti \texttt{ggplot2} e \texttt{dplyr}, ad esempio, si usa
la seguente istruzione:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{update.packages}\NormalTok{(}\FunctionTok{c}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{, }\StringTok{"dplyr"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Per eseguire l'upgrade di tutti i pacchetti l'istruzione è

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{update.packages}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{caricare-un-pacchetto-in-r}{%
\subsection{Caricare un pacchetto in R}\label{caricare-un-pacchetto-in-r}}

L'istallazione dei pacchetti non rende immediatamente disponibili le
funzioni in essi contenute. L'istallazione di un pacchetto semplicemente
copia il codice sul disco rigido della macchina in uso. Per potere usare
le funzioni contenute in un pacchetto installato è necessario caricare
il pacchetto in . Ciò si ottiene con il comando:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

se si vuole caricare il pacchetto \texttt{ggplot2}. A questo punto diventa
possibile usare le funzioni contenute in \texttt{ggplot2}. Queste operazioni si
possono anche eseguire usando dal menu a tendina di RStudio.

Per sapere quali sono i pacchetti già presenti nella release di \texttt{R} con
cui si sta lavorando, basta scrivere:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{chapter-strutture-dati}{%
\section{Strutture di dati}\label{chapter-strutture-dati}}

Solitamente gli psicologi raccolgono grandi quantità di dati. Tali dati
vengono codificati in \texttt{R} all'interno di oggetti aventi proprietà
diverse. Intuitivamente, in \texttt{R} un oggetto è qualsiasi cosa a cui è
possibile assegnare un valore. I dati possono essere di tipo numerico o
alfanumerico. Di conseguenza, \texttt{R}distingue tra oggetti aventi \emph{modi}
diversi. Inoltre, i dati possono essere organizzati in righe e colonne
in base a diversi tipi di strutture che \texttt{R} chiama \emph{classi}.

\hypertarget{classi-e-modi-degli-oggetti}{%
\subsection{Classi e modi degli oggetti}\label{classi-e-modi-degli-oggetti}}

Gli oggetti \texttt{R} si distinguono a seconda della loro classe (\emph{class}) e
del loro modo (\emph{mode}). La classe definisce il tipo di oggetto. In \texttt{R},
vengono utilizzate cinque strutture di dati che corrispondono a cinque
classi differenti: \texttt{vector}, \texttt{matrix}, \texttt{array}, \texttt{list} e \texttt{data.frame}.
Un'altra classe di oggetti \texttt{R} è \texttt{function} (ad essa appartengono le
funzioni).

La classe di appartenenza di un oggetto si stabilisce usando le funzioni
\texttt{class()}, oppure \texttt{is.list()}, \texttt{is.function()}, \texttt{is.logical()}, e così
via. Queste funzioni restituisco \texttt{TRUE} e \texttt{FALSE} in base
all'appartenenza o meno dell'argomento a quella determinata classe.

Gli oggetti \texttt{R} possono anche essere classificati in base al loro `modo'.
I modi `atomici' degli oggetti sono: \texttt{numeric}, \texttt{complex}, \texttt{character} e
\texttt{logical}. Per esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{9}\NormalTok{)}
\FunctionTok{mode}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] "numeric"}
\NormalTok{cards }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"9 of clubs"}\NormalTok{, }\StringTok{"10 of hearts"}\NormalTok{, }\StringTok{"jack of hearts"}\NormalTok{)}
\FunctionTok{mode}\NormalTok{(cards)}
\CommentTok{\#\textgreater{} [1] "character"}
\end{Highlighting}
\end{Shaded}

Nel seguito verranno esaminate le cinque strutture di dati utilizzate da
\texttt{R}.

\hypertarget{vettori}{%
\subsection{Vettori}\label{vettori}}

I vettori sono la classe di oggetto più importante in \texttt{R}. Un vettore può
essere creato usando la funzione \texttt{c()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{, }\SpecialCharTok{{-}}\DecValTok{3}\NormalTok{, }\DecValTok{9}\NormalTok{)}
\NormalTok{y}
\CommentTok{\#\textgreater{} [1]  2  1  6 {-}3  9}
\end{Highlighting}
\end{Shaded}

Le dimensioni di un vettore presente nella memoria di lavoro possono essere trovare con la funzione \texttt{length()}; ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{length}\NormalTok{(y)}
\CommentTok{\#\textgreater{} [1] 5}
\end{Highlighting}
\end{Shaded}

ci dice che \texttt{y} è un vettore costituito da cinque elementi. La somma, il
minimo e il massimo degli elementi contenuti in un vettore si trovano
con le seguenti istruzioni:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sum}\NormalTok{(y)}
\CommentTok{\#\textgreater{} [1] 15}
\FunctionTok{min}\NormalTok{(y)}
\CommentTok{\#\textgreater{} [1] {-}3}
\FunctionTok{max}\NormalTok{(y)}
\CommentTok{\#\textgreater{} [1] 9}
\end{Highlighting}
\end{Shaded}

Mentre ci sono sei `tipi' di vettori `atomici' in \texttt{R}, noi ci
focalizzeremo sui tipi seguenti: `numeric' (`integer': \emph{e.g.}, 5;
`double': \emph{e.g.}, 5.5), `character' (\emph{e.g.}, `pippo') e `logical'
(\emph{e.g.}, \texttt{TRUE}, \texttt{FALSE}). Usiamo la funzione \texttt{typeof()} per determinare
il `tipo' di un vettore atomico. Tutti gli elementi di un vettore
atomico devono essere dello stesso tipo. La funzione \texttt{str()} rende
visibile in maniera compatta la struttura interna di un oggetto.

\hypertarget{matrici}{%
\subsection{Matrici}\label{matrici}}

Una matrice è una collezione di vettori. Il comando per generare una
matrice è \texttt{matrix()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{X }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{20}\NormalTok{, }\AttributeTok{nrow =} \DecValTok{4}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{X}
\CommentTok{\#\textgreater{}      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{\#\textgreater{} [1,]    1    5    9   13   17}
\CommentTok{\#\textgreater{} [2,]    2    6   10   14   18}
\CommentTok{\#\textgreater{} [3,]    3    7   11   15   19}
\CommentTok{\#\textgreater{} [4,]    4    8   12   16   20}
\end{Highlighting}
\end{Shaded}

Il primo argomento è il vettore i cui elementi andranno a disporsi
all'interno della matrice. È poi necessario specificare le dimensioni
della matrice e il modo in cui \texttt{R} dovrà riempire la matrice. Date le
dimensioni del vettore, la specificazione del numero di righe (secondo
argomento) è sufficiente per determinare le dimensioni della matrice.
L'argomento \texttt{byrow\ =\ FALSE} è il default. In tal caso, \texttt{R} riempie la
matrice per colonne. Se vogliamo che \texttt{R} riempia la matrice per righe,
usiamo \texttt{byrow\ =\ TRUE}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Y }\OtherTok{\textless{}{-}} \FunctionTok{matrix}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{20}\NormalTok{, }\AttributeTok{nrow =} \DecValTok{4}\NormalTok{, }\AttributeTok{byrow =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{Y}
\CommentTok{\#\textgreater{}      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{\#\textgreater{} [1,]    1    2    3    4    5}
\CommentTok{\#\textgreater{} [2,]    6    7    8    9   10}
\CommentTok{\#\textgreater{} [3,]   11   12   13   14   15}
\CommentTok{\#\textgreater{} [4,]   16   17   18   19   20}
\end{Highlighting}
\end{Shaded}

Le dimensioni di una matrice presente nella memoria di lavoro possono
essere trovare con la funzione \texttt{dim()}; ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{dim}\NormalTok{(Y)}
\CommentTok{\#\textgreater{} [1] 4 5}
\end{Highlighting}
\end{Shaded}

ci dice che \texttt{Y} è una matrice con quattro righe e cinque colonne.

\hypertarget{array}{%
\subsection{Array}\label{array}}

Un array è una collezione di matrici (si veda la
Figura \protect\hyperlink{fig:R_data_structures}{1.1}). Per costruire un array con la
funzione \texttt{array()} è necessario specificare un vettore come primo
argomento e un vettore di dimensioni, chiamato \texttt{dim}, quale secondo
argomento:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ar }\OtherTok{\textless{}{-}} \FunctionTok{array}\NormalTok{(}
  \FunctionTok{c}\NormalTok{(}\DecValTok{11}\SpecialCharTok{:}\DecValTok{14}\NormalTok{, }\DecValTok{21}\SpecialCharTok{:}\DecValTok{24}\NormalTok{, }\DecValTok{31}\SpecialCharTok{:}\DecValTok{34}\NormalTok{),}
  \AttributeTok{dim =} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Un sottoinsieme di questi dati può essere selezionato, per esempio, nel
modo seguente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ar[, , }\DecValTok{3}\NormalTok{]}
\CommentTok{\#\textgreater{}      [,1] [,2]}
\CommentTok{\#\textgreater{} [1,]   31   33}
\CommentTok{\#\textgreater{} [2,]   32   34}
\end{Highlighting}
\end{Shaded}

\hypertarget{operazioni-aritmetiche-su-vettori-matrici-e-array}{%
\subsection{Operazioni aritmetiche su vettori, matrici e array}\label{operazioni-aritmetiche-su-vettori-matrici-e-array}}

\hypertarget{operazioni-aritmetiche-su-vettori}{%
\subsubsection{Operazioni aritmetiche su vettori}\label{operazioni-aritmetiche-su-vettori}}

I vettori e le matrici (o gli array) possono essere utilizzati in
espressioni aritmetiche. Il risultato è un vettore o una matrice (o un
array) formato dalle operazioni fatte elemento per elemento sui vettori
o sulle matrici. Ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\SpecialCharTok{+} \DecValTok{3}
\CommentTok{\#\textgreater{} [1]  5  4  9  0 12}
\end{Highlighting}
\end{Shaded}

restituisce un vettore di dimensioni uguali alle dimensioni di \texttt{y}, i
cui elementi sono dati dalla somma tra ciascuno degli elementi originari
di \texttt{y} e la costante ``3''.

Ovviamente, ad un vettore possono essere applicate tutte le altre
operazioni algebriche, sempre elemento per elemento. Ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3} \SpecialCharTok{*}\NormalTok{ y}
\CommentTok{\#\textgreater{} [1]  6  3 18 {-}9 27}
\end{Highlighting}
\end{Shaded}

restituisce un vettore i cui elementi sono uguali agli elementi di \texttt{y}
moltiplicati per 3.

Se sono costituiti dallo stesso numero di elementi, due vettori possono
essere sommati, sottratti, moltiplicati e divisi, laddove queste
operazioni algebriche vengono eseguite elemento per elemento. Per
esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{y }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{9}\NormalTok{)}
\NormalTok{x }\SpecialCharTok{+}\NormalTok{ y}
\CommentTok{\#\textgreater{} [1]  3  2  8  4 12}
\NormalTok{x }\SpecialCharTok{{-}}\NormalTok{ y}
\CommentTok{\#\textgreater{} [1] {-}1  0 {-}4 {-}2 {-}6}
\NormalTok{x }\SpecialCharTok{*}\NormalTok{ y}
\CommentTok{\#\textgreater{} [1]  2  1 12  3 27}
\NormalTok{x }\SpecialCharTok{/}\NormalTok{ y}
\CommentTok{\#\textgreater{} [1] 0.5000000 1.0000000 0.3333333 0.3333333 0.3333333}
\end{Highlighting}
\end{Shaded}

\hypertarget{operazioni-aritmetiche-su-matrici}{%
\subsubsection{Operazioni aritmetiche su matrici}\label{operazioni-aritmetiche-su-matrici}}

Le operazioni algebriche elemento per elemento si possono estendere al
caso delle matrici. Per esempio, se \texttt{X}, \texttt{Y} sono entrambe matrici di
dimensioni \(4 \times 5\), allora la seguente operazione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M }\OtherTok{\textless{}{-}} \DecValTok{2} \SpecialCharTok{*}\NormalTok{ (X }\SpecialCharTok{+}\NormalTok{ Y) }\SpecialCharTok{{-}} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

crea una matrice \texttt{D} anch'essa di dimensioni \(4 \times 5\) i cui elementi
sono ottenuti dalle operazioni fatte elemento per elemento sulle matrici
e sugli scalari:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M}
\CommentTok{\#\textgreater{}      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{\#\textgreater{} [1,]    1   11   21   31   41}
\CommentTok{\#\textgreater{} [2,]   13   23   33   43   53}
\CommentTok{\#\textgreater{} [3,]   25   35   45   55   65}
\CommentTok{\#\textgreater{} [4,]   37   47   57   67   77}
\end{Highlighting}
\end{Shaded}

\hypertarget{operazioni-aritmetiche-su-array}{%
\subsubsection{Operazioni aritmetiche su array}\label{operazioni-aritmetiche-su-array}}

Le stesse considerazioni si estendono al caso degli array.

\hypertarget{liste}{%
\subsection{Liste}\label{liste}}

Le liste assomigliano ai vettori perché raggruppano i dati in un insieme
unidimensionale. Tuttavia, le liste non raggruppano elementi individuali
ma bensì oggetti di \texttt{R}, quali vettori e altre liste. Per esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list1 }\OtherTok{\textless{}{-}} \FunctionTok{list}\NormalTok{(}\StringTok{"R"}\NormalTok{, }\FunctionTok{list}\NormalTok{(}\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{), }\DecValTok{20}\SpecialCharTok{:}\DecValTok{24}\NormalTok{)}
\NormalTok{list1}
\CommentTok{\#\textgreater{} [[1]]}
\CommentTok{\#\textgreater{} [1] "R"}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} [[2]]}
\CommentTok{\#\textgreater{} [[2]][[1]]}
\CommentTok{\#\textgreater{} [1] TRUE}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} [[2]][[2]]}
\CommentTok{\#\textgreater{} [1] FALSE}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} [[3]]}
\CommentTok{\#\textgreater{} [1] 20 21 22 23 24}
\end{Highlighting}
\end{Shaded}

Le doppie parentesi quadre identificano l'elemento della lista a cui
vogliamo fare riferimento. Per esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list1[[}\DecValTok{3}\NormalTok{]]}
\CommentTok{\#\textgreater{} [1] 20 21 22 23 24}
\NormalTok{list1[[}\DecValTok{3}\NormalTok{]][}\DecValTok{2}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] 21}
\end{Highlighting}
\end{Shaded}

\hypertarget{data-frame}{%
\subsection{Data frame}\label{data-frame}}

I data.frame sono strutture tipo matrice, in cui le colonne possono
essere vettori di tipi differenti. La funzione usata per generare un
data frame è \texttt{data.frame()}, che permette di unire più vettori di uguale
lunghezza come colonne del data frame, ognuno dei quali si riferisce ad
una diversa variabile. Ad esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{face =} \FunctionTok{c}\NormalTok{(}\StringTok{"ace"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"six"}\NormalTok{),}
  \AttributeTok{suit =} \FunctionTok{c}\NormalTok{(}\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{),}
  \AttributeTok{value =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{)}
\NormalTok{df}
\CommentTok{\#\textgreater{}   face  suit value}
\CommentTok{\#\textgreater{} 1  ace clubs     1}
\CommentTok{\#\textgreater{} 2  two clubs     2}
\CommentTok{\#\textgreater{} 3  six clubs     3}
\end{Highlighting}
\end{Shaded}

L'estrazione di dati da un data.frame può essere effettuata in maniera
simile a quanto avviene per i vettori. Ad esempio, per estrarre la
variabile \texttt{value} dal data.frame \texttt{df} si può indicare l'indice della
terza colonna:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[, }\DecValTok{3}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] 1 2 3}
\end{Highlighting}
\end{Shaded}

Dal momento che le colonne sono delle variabili, è possibile estrarle
anche indicando nome della variabile, scrivendo
\texttt{nome\_data\_frame\$nome\_variabile}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df}\SpecialCharTok{$}\NormalTok{value}
\CommentTok{\#\textgreater{} [1] 1 2 3}
\end{Highlighting}
\end{Shaded}

Per fare un esempio, creiamo un data.frame che contenga tutte le informazioni di un mazzo di carte da poker \citep{grolemund2014hands}. In tale data.frame, ciascuna riga
corrisponde ad una carta -- in un mazzo da poker ci sono 52 carte,
perciò il data.frame avrà 52 righe. Il vettore \texttt{face} indica con una
stringa di caratteri il valore di ciascuna carta, il vettore \texttt{suit}
indica il seme e il vettore \texttt{value} indica con un numero intero il
valore di ciascuna carta. Quindi, il data.frame avrà 3 colonne.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(}
  \AttributeTok{face =} \FunctionTok{c}\NormalTok{(}
    \StringTok{"king"}\NormalTok{, }\StringTok{"queen"}\NormalTok{, }\StringTok{"jack"}\NormalTok{, }\StringTok{"ten"}\NormalTok{, }\StringTok{"nine"}\NormalTok{, }\StringTok{"eight"}\NormalTok{,}
    \StringTok{"seven"}\NormalTok{, }\StringTok{"six"}\NormalTok{, }\StringTok{"five"}\NormalTok{, }\StringTok{"four"}\NormalTok{, }\StringTok{"three"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"ace"}\NormalTok{,}
    \StringTok{"king"}\NormalTok{, }\StringTok{"queen"}\NormalTok{, }\StringTok{"jack"}\NormalTok{, }\StringTok{"ten"}\NormalTok{, }\StringTok{"nine"}\NormalTok{, }\StringTok{"eight"}\NormalTok{, }\StringTok{"seven"}\NormalTok{,}
    \StringTok{"six"}\NormalTok{, }\StringTok{"five"}\NormalTok{, }\StringTok{"four"}\NormalTok{, }\StringTok{"three"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"ace"}\NormalTok{, }\StringTok{"king"}\NormalTok{,}
    \StringTok{"queen"}\NormalTok{, }\StringTok{"jack"}\NormalTok{, }\StringTok{"ten"}\NormalTok{, }\StringTok{"nine"}\NormalTok{, }\StringTok{"eight"}\NormalTok{, }\StringTok{"seven"}\NormalTok{, }\StringTok{"six"}\NormalTok{,}
    \StringTok{"five"}\NormalTok{, }\StringTok{"four"}\NormalTok{, }\StringTok{"three"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"ace"}\NormalTok{, }\StringTok{"king"}\NormalTok{, }\StringTok{"queen"}\NormalTok{,}
    \StringTok{"jack"}\NormalTok{, }\StringTok{"ten"}\NormalTok{, }\StringTok{"nine"}\NormalTok{, }\StringTok{"eight"}\NormalTok{, }\StringTok{"seven"}\NormalTok{, }\StringTok{"six"}\NormalTok{, }\StringTok{"five"}\NormalTok{,}
    \StringTok{"four"}\NormalTok{, }\StringTok{"three"}\NormalTok{, }\StringTok{"two"}\NormalTok{, }\StringTok{"ace"}
\NormalTok{  ),}
  \AttributeTok{suit =} \FunctionTok{c}\NormalTok{(}
    \StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{,}
    \StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{,}
    \StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"spades"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{,}
    \StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{,}
    \StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"clubs"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{,}
    \StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{,}
    \StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{,}
    \StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"diamonds"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{,}
    \StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{,}
    \StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}\NormalTok{,}
    \StringTok{"hearts"}\NormalTok{, }\StringTok{"hearts"}
\NormalTok{  ),}
  \AttributeTok{value =} \FunctionTok{c}\NormalTok{(}\DecValTok{13}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Avendo salvato tutte queste informazioni nell'oggetto \texttt{deck}, possiamo
stamparle sullo schermo semplicemente digitando il nome dell'oggetto che
le contiene:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck}
\CommentTok{\#\textgreater{}     face     suit value}
\CommentTok{\#\textgreater{} 1   king   spades    13}
\CommentTok{\#\textgreater{} 2  queen   spades    12}
\CommentTok{\#\textgreater{} 3   jack   spades    11}
\CommentTok{\#\textgreater{} 4    ten   spades    10}
\CommentTok{\#\textgreater{} 5   nine   spades     9}
\CommentTok{\#\textgreater{} 6  eight   spades     8}
\CommentTok{\#\textgreater{} 7  seven   spades     7}
\CommentTok{\#\textgreater{} 8    six   spades     6}
\CommentTok{\#\textgreater{} 9   five   spades     5}
\CommentTok{\#\textgreater{} 10  four   spades     4}
\CommentTok{\#\textgreater{} 11 three   spades     3}
\CommentTok{\#\textgreater{} 12   two   spades     2}
\CommentTok{\#\textgreater{} 13   ace   spades     1}
\CommentTok{\#\textgreater{} 14  king    clubs    13}
\CommentTok{\#\textgreater{} 15 queen    clubs    12}
\CommentTok{\#\textgreater{} 16  jack    clubs    11}
\CommentTok{\#\textgreater{} 17   ten    clubs    10}
\CommentTok{\#\textgreater{} 18  nine    clubs     9}
\CommentTok{\#\textgreater{} 19 eight    clubs     8}
\CommentTok{\#\textgreater{} 20 seven    clubs     7}
\CommentTok{\#\textgreater{} 21   six    clubs     6}
\CommentTok{\#\textgreater{} 22  five    clubs     5}
\CommentTok{\#\textgreater{} 23  four    clubs     4}
\CommentTok{\#\textgreater{} 24 three    clubs     3}
\CommentTok{\#\textgreater{} 25   two    clubs     2}
\CommentTok{\#\textgreater{} 26   ace    clubs     1}
\CommentTok{\#\textgreater{} 27  king diamonds    13}
\CommentTok{\#\textgreater{} 28 queen diamonds    12}
\CommentTok{\#\textgreater{} 29  jack diamonds    11}
\CommentTok{\#\textgreater{} 30   ten diamonds    10}
\CommentTok{\#\textgreater{} 31  nine diamonds     9}
\CommentTok{\#\textgreater{} 32 eight diamonds     8}
\CommentTok{\#\textgreater{} 33 seven diamonds     7}
\CommentTok{\#\textgreater{} 34   six diamonds     6}
\CommentTok{\#\textgreater{} 35  five diamonds     5}
\CommentTok{\#\textgreater{} 36  four diamonds     4}
\CommentTok{\#\textgreater{} 37 three diamonds     3}
\CommentTok{\#\textgreater{} 38   two diamonds     2}
\CommentTok{\#\textgreater{} 39   ace diamonds     1}
\CommentTok{\#\textgreater{} 40  king   hearts    13}
\CommentTok{\#\textgreater{} 41 queen   hearts    12}
\CommentTok{\#\textgreater{} 42  jack   hearts    11}
\CommentTok{\#\textgreater{} 43   ten   hearts    10}
\CommentTok{\#\textgreater{} 44  nine   hearts     9}
\CommentTok{\#\textgreater{} 45 eight   hearts     8}
\CommentTok{\#\textgreater{} 46 seven   hearts     7}
\CommentTok{\#\textgreater{} 47   six   hearts     6}
\CommentTok{\#\textgreater{} 48  five   hearts     5}
\CommentTok{\#\textgreater{} 49  four   hearts     4}
\CommentTok{\#\textgreater{} 50 three   hearts     3}
\CommentTok{\#\textgreater{} 51   two   hearts     2}
\CommentTok{\#\textgreater{} 52   ace   hearts     1}
\end{Highlighting}
\end{Shaded}

Si noti che, a schermo, \texttt{R} stampa un numero progressivo che corrisponde
al numero della riga.

\hypertarget{selezione-di-elementi}{%
\subsubsection{Selezione di elementi}\label{selezione-di-elementi}}

Una volta creato un data.frame, ad esempio quello che contiene un mazzo
virtuale di carte (si veda
l'esempio~\protect\hyperlink{exmp:deck_of_cards}{\[exmp:deck_of_cards\]}), è necessario sapere come manipolarlo.
La funzione \texttt{head()} mostra le prime sei righe del data.frame:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{head}\NormalTok{(deck)}
\CommentTok{\#\textgreater{}    face   suit value}
\CommentTok{\#\textgreater{} 1  king spades    13}
\CommentTok{\#\textgreater{} 2 queen spades    12}
\CommentTok{\#\textgreater{} 3  jack spades    11}
\CommentTok{\#\textgreater{} 4   ten spades    10}
\CommentTok{\#\textgreater{} 5  nine spades     9}
\CommentTok{\#\textgreater{} 6 eight spades     8}
\end{Highlighting}
\end{Shaded}

Poniamoci ora il problema di mescolare il mazzo di carte e di estrarre
alcune carte dal mazzo. Queste operazioni possono essere eseguite usando
il sistema notazionale di \texttt{R}.

Il sistema di notazione di \texttt{R} consente di estrarre singoli elementi
dagli oggetti definiti da \texttt{R}. Per estrarre un valore da un data.frame,
per esempio, dobbiamo scrivere il nome del data.frame seguito da una
coppia di parentesi quadre:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[, ]}
\end{Highlighting}
\end{Shaded}

All'interno delle parentesi quadre ci sono due indici separati da una
virgola. \texttt{R} usa il primo indice per selezionare un sottoinsieme di righe
del data.frame e il secondo indice per selezionare un sottoinsieme di
colonne. L'indice è il numero d'ordine che etichetta progressivamente ognuno dei valori del vettore. Per esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{9}\NormalTok{, }\DecValTok{2}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] "spades"}
\end{Highlighting}
\end{Shaded}

restituisce l'elemento che si trova nella nella nona riga della seconda
colonna di \texttt{deck}.

In \texttt{R} ci sono sei modi diversi per specificare gli indici di un oggetto:
interi positivi, interi negativi, zero, spazi vuoti, valori logici e
nomi. Esaminiamoli qui di seguito.

\hypertarget{interi-positivi}{%
\subsubsection{Interi positivi}\label{interi-positivi}}

Gli indici \(i, j\) possono essere degli interi positivi che identificano
l'elemento nella \(i\)-esima riga e nella \(j\)-esima colonna del
data.frame. Per l'esempio relativo al mazzo di carte, l'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{]}
\CommentTok{\#\textgreater{} [1] "king"}
\end{Highlighting}
\end{Shaded}

ritorna il valore nella prima riga e nella prima colonna. Per estrarre
più di un valore, usiamo un vettore di interi positivi. Per esempio, la
prima riga di \texttt{deck} si trova con

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{1}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{)]}
\CommentTok{\#\textgreater{}   face   suit value}
\CommentTok{\#\textgreater{} 1 king spades    13}
\end{Highlighting}
\end{Shaded}

Tale sistema notazionale non si applica solo ai data.frame ma può essere
usato anche per gli altri oggetti di \texttt{R}.

L'indice usato da \texttt{R} inizia da 1. In altri linguaggi di programmazione,
per esempio \texttt{C}, inizia da 0.

\hypertarget{interi-negativi}{%
\subsubsection{Interi negativi}\label{interi-negativi}}

Gli interi negativi fanno l'esatto contrario degli interi positivi: R
ritornerà tutti gli elementi tranne quelli specificati dagli interi
negativi. Per esempio, la prima riga del data.frame può essere
specificata nel modo seguente

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\SpecialCharTok{{-}}\NormalTok{(}\DecValTok{2}\SpecialCharTok{:}\DecValTok{52}\NormalTok{), }\DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{]}
\CommentTok{\#\textgreater{}   face   suit value}
\CommentTok{\#\textgreater{} 1 king spades    13}
\end{Highlighting}
\end{Shaded}

ovvero, escludendo tutte le righe seguenti.

\hypertarget{zero}{%
\subsubsection{Zero}\label{zero}}

Quando lo zero viene usato come indice, \texttt{R} non ritorna nulla dalla
dimensione a cui lo zero si riferisce. L'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{]}
\CommentTok{\#\textgreater{} data frame con 0 colonne e 0 righe}
\end{Highlighting}
\end{Shaded}

ritorna un data.frame vuoto. Non molto utile.

\hypertarget{spazio}{%
\subsubsection{\texorpdfstring{Spazio \texttt{’\ ’}}{Spazio ' '}}\label{spazio}}

Uno spazio viene usato quale indice per comunicare a \texttt{R} di estrarre
tutti i valori in quella dimensione. Questo è utile per estrarre intere
colonne o intere righe da un data.frame. Per esempio, l'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{3}\NormalTok{, ]}
\CommentTok{\#\textgreater{}   face   suit value}
\CommentTok{\#\textgreater{} 3 jack spades    11}
\end{Highlighting}
\end{Shaded}

ritorna la terza riga del data.frame \texttt{deck}.

\hypertarget{valori-booleani}{%
\subsubsection{Valori booleani}\label{valori-booleani}}

Se viene fornito un vettore di stringhe \texttt{TRUE}, \texttt{FALSE}, \texttt{R} selezionerà
gli elementi riga o colonna corrispondenti ai valori booleani \texttt{TRUE}
usati quali indici. Per esempio, l'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{3}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{TRUE}\NormalTok{, }\ConstantTok{FALSE}\NormalTok{)]}
\CommentTok{\#\textgreater{}   face   suit}
\CommentTok{\#\textgreater{} 3 jack spades}
\end{Highlighting}
\end{Shaded}

ritorna i valori delle prime due colonne della terza riga di \texttt{deck}.

\hypertarget{nomi}{%
\subsubsection{Nomi}\label{nomi}}

È possibile selezionare gli elementi del data.frame usando i loro nomi.
Per esempio,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{1}\NormalTok{, }\FunctionTok{c}\NormalTok{(}\StringTok{"face"}\NormalTok{, }\StringTok{"suit"}\NormalTok{, }\StringTok{"value"}\NormalTok{)]}
\CommentTok{\#\textgreater{}   face   suit value}
\CommentTok{\#\textgreater{} 1 king spades    13}
\NormalTok{deck[, }\StringTok{"value"}\NormalTok{]}
\CommentTok{\#\textgreater{}  [1] 13 12 11 10  9  8  7  6  5  4  3  2  1 13 12 11 10  9}
\CommentTok{\#\textgreater{} [19]  8  7  6  5  4  3  2  1 13 12 11 10  9  8  7  6  5  4}
\CommentTok{\#\textgreater{} [37]  3  2  1 13 12 11 10  9  8  7  6  5  4  3  2  1}
\end{Highlighting}
\end{Shaded}

\hypertarget{giochi-di-carte}{%
\subsection{Giochi di carte}\label{giochi-di-carte}}

Avendo presentato le nozioni base del sistema di notazione di \texttt{R},
utilizziamo tali conoscenze per manipolare il data.frame. L'istruzione

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck[}\DecValTok{1}\SpecialCharTok{:}\DecValTok{52}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

ritorna tutte le righe e tutte e le colonne del data.frame \texttt{deck}. Le
righe sono identificate dal primo indice, che va da 1 a 52. Permutare in
modo casuale l'indice delle righe equivale a mescolare il mazzo di
carte. Per fare questo, utilizziamo la funzione \texttt{sample()} ponendo \texttt{replace=FALSE} e \texttt{size}
uguale alla dimensione del vettore che contiene gli indici da 1 a 52:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{random }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{52}\NormalTok{, }\AttributeTok{size =} \DecValTok{52}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{FALSE}\NormalTok{)}
\NormalTok{random}
\CommentTok{\#\textgreater{}  [1] 49 37  1 25 10 36 18 24  7 47 52 51 20 26  3 42 27 31}
\CommentTok{\#\textgreater{} [19]  5 40  2 28  8 38 39 50 48 45 11 15 22 30  4 33 46 13}
\CommentTok{\#\textgreater{} [37] 12 34 19 32 21 17 29 16 44 43 23 41  6 14 35  9}
\end{Highlighting}
\end{Shaded}

Utilizzando il vettore \texttt{random} di indici permutati otteniamo il
risultato cercato:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck\_shuffled }\OtherTok{\textless{}{-}}\NormalTok{ deck[random, ]}
\FunctionTok{head}\NormalTok{(deck\_shuffled)}
\CommentTok{\#\textgreater{}     face     suit value}
\CommentTok{\#\textgreater{} 49  four   hearts     4}
\CommentTok{\#\textgreater{} 37 three diamonds     3}
\CommentTok{\#\textgreater{} 1   king   spades    13}
\CommentTok{\#\textgreater{} 25   two    clubs     2}
\CommentTok{\#\textgreater{} 10  four   spades     4}
\CommentTok{\#\textgreater{} 36  four diamonds     4}
\end{Highlighting}
\end{Shaded}

Possiamo ora scrivere una funzione che include le precedenti istruzioni:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{shuffle }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(cards) \{}
\NormalTok{  random }\OtherTok{\textless{}{-}} \FunctionTok{sample}\NormalTok{(}\DecValTok{1}\SpecialCharTok{:}\DecValTok{52}\NormalTok{, }\AttributeTok{size =} \DecValTok{52}\NormalTok{, }\AttributeTok{replace =} \ConstantTok{FALSE}\NormalTok{)}
  \FunctionTok{return}\NormalTok{(cards[random, ])}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Invocando la funzione \texttt{shuffle()} possiamo generare un data.frame che
rappresenta un mazzo di carte mescolato:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck\_shuffled }\OtherTok{\textless{}{-}} \FunctionTok{shuffle}\NormalTok{(deck)}
\end{Highlighting}
\end{Shaded}

Se immaginiamo di distribuire le carte di questo mazzo a due giocatori
di poker, per il primo giocatore avremo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck\_shuffled[}\FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{9}\NormalTok{), ]}
\CommentTok{\#\textgreater{}     face     suit value}
\CommentTok{\#\textgreater{} 52   ace   hearts     1}
\CommentTok{\#\textgreater{} 21   six    clubs     6}
\CommentTok{\#\textgreater{} 38   two diamonds     2}
\CommentTok{\#\textgreater{} 40  king   hearts    13}
\CommentTok{\#\textgreater{} 33 seven diamonds     7}
\end{Highlighting}
\end{Shaded}

e per il secondo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deck\_shuffled[}\FunctionTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{10}\NormalTok{), ]}
\CommentTok{\#\textgreater{}     face     suit value}
\CommentTok{\#\textgreater{} 3   jack   spades    11}
\CommentTok{\#\textgreater{} 2  queen   spades    12}
\CommentTok{\#\textgreater{} 10  four   spades     4}
\CommentTok{\#\textgreater{} 5   nine   spades     9}
\CommentTok{\#\textgreater{} 39   ace diamonds     1}
\end{Highlighting}
\end{Shaded}

\hypertarget{variabili-locali}{%
\subsection{Variabili locali}\label{variabili-locali}}

Si noti che, nell'esempio precedente, abbiamo passato l'argomento \texttt{deck}
alla funzione \texttt{shuffle()}, perché questo è il nome del data.frame che
volevamo manipolare. Nella definizione della funzione \texttt{shuffle()}, però,
l'argomento della funzione era chiamato \texttt{cards}. Il nome degli argomenti
è diverso nei due casi. Allora perché l'istruzione \texttt{shuffle(deck)} non
dà un messaggio d'errore?

La risposta a questa domanda è che nelle funzioni le variabili nascono
quando la funzione entra in esecuzione e muoiono al termine
dell'esecuzione della funzione. Per questa ragione, sono dette `locali'.
La variabile \texttt{cards}, in questo esempio, esiste soltanto all'interno
della funzione. Dunque non deve (necessariamente) avere lo stesso nome
di un altro oggetto che esiste al di fuori della funzione, nello spazio
di lavoro di R (anzi, è meglio se il nome degli oggetti usati
all'interno delle funzioni è diverso da quello degli oggetti che
esistono fuori dalle funzioni). R sa che l'oggetto \texttt{deck} passato a
\texttt{shuffle()} corrisponde a \texttt{cards} all'interno della funzione perché
assegna il nome \texttt{cards} a qualunque oggetto venga passato alla funzione
\texttt{shuffle()} come primo (e, in questo caso, unico) argomento.

\hypertarget{chapter-strut-contr}{%
\section{Strutture di controllo}\label{chapter-strut-contr}}

In \texttt{R} il flusso della computazione segue l'ordine di lettura delle espressioni. I controlli di flusso sono quei costrutti sintattici che possono modificare quest'ordine di computazione. Ad esempio, un ciclo \texttt{for} ripete le istruzioni annidate al suo interno per un certo numero di volte, e quindi procede sequenzialmente da lì in avanti, mentre un condizionale \texttt{if} valuta una condizione rispetto alla quale il flusso di informazioni si biforca (se è vero / se è falso). Ci limitiamo qui ad introdurre il ciclo \texttt{for}.

\hypertarget{il-ciclo-for}{%
\subsection{\texorpdfstring{Il ciclo \texttt{for}}{Il ciclo for}}\label{il-ciclo-for}}

Il ciclo \texttt{for} è una struttura di controllo iterativa che determina l'esecuzione di una porzione di codice ripetuta per un certo numero noto di volte. Il linguaggio \texttt{R} usa la seguente sintassi per il ciclo \texttt{for}:

\texttt{for} (\texttt{indice} in \texttt{valori\_indice}) \{
\emph{operazioni}
\}

il che significa ``esegui le operazioni \emph{operazioni} per i diversi valori di \texttt{indice} compresi nel vettore \texttt{valori\_indice}''. Per esempio, il seguente ciclo \texttt{for} non fa altro che stampare il valore della variabile contatore in ciascuna esecuzione del ciclo:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\DecValTok{3}\NormalTok{) \{}
  \FunctionTok{print}\NormalTok{(i)}
\NormalTok{\}}
\CommentTok{\#\textgreater{} [1] 1}
\CommentTok{\#\textgreater{} [1] 2}
\CommentTok{\#\textgreater{} [1] 3}
\end{Highlighting}
\end{Shaded}

Un esempio (leggermente) più complicato è il seguente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x\_list }\OtherTok{\textless{}{-}} \FunctionTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{9}\NormalTok{, }\AttributeTok{by =} \DecValTok{2}\NormalTok{)}
\NormalTok{x\_list}
\CommentTok{\#\textgreater{} [1] 1 3 5 7 9}
\NormalTok{sum\_x }\OtherTok{\textless{}{-}} \DecValTok{0}
\ControlFlowTok{for}\NormalTok{ (x }\ControlFlowTok{in}\NormalTok{ x\_list) \{}
\NormalTok{  sum\_x }\OtherTok{\textless{}{-}}\NormalTok{ sum\_x }\SpecialCharTok{+}\NormalTok{ x}
  \FunctionTok{cat}\NormalTok{(}\StringTok{"L\textquotesingle{}indice corrente e\textquotesingle{}"}\NormalTok{, x, }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
  \FunctionTok{cat}\NormalTok{(}\StringTok{"La frequenza cumulata e\textquotesingle{}"}\NormalTok{, sum\_x, }\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{\}}
\CommentTok{\#\textgreater{} L\textquotesingle{}indice corrente e\textquotesingle{} 1 }
\CommentTok{\#\textgreater{} La frequenza cumulata e\textquotesingle{} 1 }
\CommentTok{\#\textgreater{} L\textquotesingle{}indice corrente e\textquotesingle{} 3 }
\CommentTok{\#\textgreater{} La frequenza cumulata e\textquotesingle{} 4 }
\CommentTok{\#\textgreater{} L\textquotesingle{}indice corrente e\textquotesingle{} 5 }
\CommentTok{\#\textgreater{} La frequenza cumulata e\textquotesingle{} 9 }
\CommentTok{\#\textgreater{} L\textquotesingle{}indice corrente e\textquotesingle{} 7 }
\CommentTok{\#\textgreater{} La frequenza cumulata e\textquotesingle{} 16 }
\CommentTok{\#\textgreater{} L\textquotesingle{}indice corrente e\textquotesingle{} 9 }
\CommentTok{\#\textgreater{} La frequenza cumulata e\textquotesingle{} 25}
\end{Highlighting}
\end{Shaded}

Per esempio, quanti numeri pari sono contenuti in un vettore? La
risposta a questa domanda viene fornita dalla funzione
\texttt{countEvenNumbers()} che possiamo definire come indicato qui sotto:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{countEvenNumbers }\OtherTok{\textless{}{-}} \ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  count }\OtherTok{\textless{}{-}} \DecValTok{0}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\SpecialCharTok{:}\FunctionTok{length}\NormalTok{(x)) \{}
    \ControlFlowTok{if}\NormalTok{ (x[i] }\SpecialCharTok{\%\%} \DecValTok{2} \SpecialCharTok{==} \DecValTok{0}\NormalTok{) \{}
\NormalTok{      count }\OtherTok{\textless{}{-}}\NormalTok{ count }\SpecialCharTok{+} \DecValTok{1}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  count}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Nella funzione \texttt{countEvenNumbers()} abbiamo inizializzato la variabile
\texttt{count} a zero. Prima dell'esecuzione del ciclo \texttt{for}, dunque, \texttt{count}
vale zero. Il ciclo \texttt{for} viene eseguito tante volte quanti sono gli
elementi che costituiscono il vettore \texttt{x}. L'indice \texttt{i} dunque assume
valori compresi tra 1 e il valore che corrisponde al numero di elementi
di \texttt{x}. L'operazione modulo, indicato con \texttt{\%\%} dà come risultato il
resto della divisione euclidea del primo numero per il secondo. Per
esempio, \texttt{9\ \%\%\ 2} dà come risultato \(1\) perché questo è il resto della
divisione \(9/2\). L'operazione modulo dà come risultato \(0\) per tutti i
numeri pari. In ciascuna esecuzione del ciclo \texttt{for} l'operazione modulo
viene eseguita, successivamente, su uno degli elementi di \texttt{x}. Se
l'operazione modulo dà \(0\) come risultato, ovvero se il valore
considerato è un numero pari, allora la variabile \texttt{count} viene
incrementata di un'unità. L'istruzione \texttt{return()} ritorna il
numero di valori pari contenuti nel vettore di input alla funzione.
Si noti che è necessario usare \texttt{return()}: la funzione ritornerà qualunque cosa sia stampato nell'ultima riga della funzione stessa.

Facciamo un esempio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{12}\NormalTok{)}
\FunctionTok{countEvenNumbers}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1] 4}
\end{Highlighting}
\end{Shaded}

\hypertarget{chapter-input-output}{%
\section{Input/Output}\label{chapter-input-output}}

I dati raccolti dallo psicologo sono contenuti in file aventi formati
diversi: solo testo, CSV, Excel, eccetera. \texttt{R} prevede diverse funzioni
di importazione dei dati. Esamineremo qui la funzione \texttt{read.table()} per
l'importazione di dati in formato solo testo, ma funzioni analoghe
possono essere usate per molti altri formati possibili.

\hypertarget{la-funzione-read.table}{%
\subsection{\texorpdfstring{La funzione \texttt{read.table()}}{La funzione read.table()}}\label{la-funzione-read.table}}

Ci sono tanti modi per importare un file dal nostro computer. \texttt{R} permette di utilizzare delle funzioni che sono già nella libreria di base, oppure possiamo utilizzare delle funzioni specifiche, a seconda del tipo di file da importare, che sono contenute in pacchetti aggiuntivi. Per leggere i dati da file in \texttt{R} è conveniente
preliminarmente generare un file di dati in formato ASCII, disponendoli
come si farebbe in una matrice di dati, e mettere questo file nella
cartella di lavoro corrente. Fatto questo, si può utilizzare la funzione
\texttt{read.table()} presente nella libreria di base per leggere l'intero
dataset. Se la prima riga del file contiene l'intestazione delle
variabili, allora \texttt{read.table("my\_file.txt",\ header\ =\ TRUE)}
interpreterà la prima riga del file come una riga dove sono contenuti i
nomi delle variabili, assegnando ciascun nome alle variabili del data
frame:

\begin{verbatim}
mydata <- read.table("my_file.txt", header = TRUE)
\end{verbatim}

In alternativa, si può impiegare la funzione \texttt{read.csv()}, che è adatta
a leggere dati salvati in \texttt{.csv}. Utilizzando altre funzioni, si possono
leggere in R  i dati contenuti in file aventi formati diversi da quelli
considerati qui, quali Excel, SPSS, ecc.

\hypertarget{file-di-dati-forniti-da-r}{%
\subsection{File di dati forniti da R}\label{file-di-dati-forniti-da-r}}

In \texttt{R} esistono comunque oltre 50 insiemi di dati contenuti nel package
\texttt{base} e altri sono disponibili in altri packages. Per vedere l'elenco
degli insiemi di dati disponibili nel package \texttt{base} basta usare
l'istruzione \texttt{data()}; per caricare un particolare insieme di dati, ad
esempio \texttt{cars}, basta utilizzare l'istruzione

\begin{verbatim}
data(cars)
\end{verbatim}

Nella maggior parte dei casi questo corrisponde a caricare un oggetto,
solitamente un data.frame dello stesso nome: per l'esempio considerato
si avrebbe un data frame di nome \texttt{cars}.

\hypertarget{esportazione-di-un-file}{%
\section{Esportazione di un file}\label{esportazione-di-un-file}}

Per esportare un data.frame in formato \texttt{.csv} possiamo scrivere il
seguente codice

\begin{verbatim}
write.csv(df_esempio, file = "esempio.csv", row.names = FALSE)
\end{verbatim}

dove \texttt{df\_esempio} è il data.frame da salvare e \texttt{esempio.csv} è il file
che verrà salvato all'interno della nostra cartellla di lavoro.

\hypertarget{pacchetto-rio}{%
\subsection{\texorpdfstring{Pacchetto \texttt{rio}}{Pacchetto rio}}\label{pacchetto-rio}}

Un'alternativa più semplice è fornita dalle funzioni fornite dal pacchetto \texttt{rio}. Per importare i dati da un file in qualsiasi formato si usa

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_data\_frame }\OtherTok{\textless{}{-}}\NormalTok{ rio}\SpecialCharTok{::}\FunctionTok{import}\NormalTok{(}\StringTok{"my\_file.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Per esportare i dati in un file avente qualsiasi formato si usa invece

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rio}\SpecialCharTok{::}\FunctionTok{export}\NormalTok{(my\_data\_frame, }\StringTok{"my\_file.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{dove-sono-i-miei-file}{%
\subsection{Dove sono i miei file?}\label{dove-sono-i-miei-file}}

Quello che abbiamo detto finora, a proposito dell'importazione ed esportazione dei file, si riferisce a file che si trovano nella cartella di lavoro (\emph{working directory}). Ma non sempre ci troviamo in questa situazione, il che è anche una buona cosa, perché se dobbiamo gestire un progetto anche leggermente complesso è sempre una buona idea salvare i file che usiamo in cartelle diverse. Per esempio, possiamo usare una cartella chiamata \texttt{psicometria} dove salviamo tutto il materiale di questo insegnamento. Nella cartella \texttt{psicometria} ci potrà essere una cartella chiamata \texttt{scripts} dove salveremo gli script con il codice R utilizzato per i vari esercizi, e una cartella chiamata \texttt{data} dove possiamo salvare i dati. Questa organizzazione minimale ci pone, però, difronte ad un problema: i dati che vogliamo caricare in R non si trovano più nella cartella dove sono contenuti gli script. Quando importiamo un file di dati dobbiamo dunque specificare il percorso che identifica la posizione sul nostro computer del file che ci interessa.

Questo problema può essere risolto in due modi: speficicando l'inridizzo del file in modo assoluto o relativo. Specificare l'indirizzo di un file in modo assoluto ha una serie di limiti. Il più grande è che non sarà possibile utilizzare quell'istruzione su una macchina diversa. Dunque, è molto più conveniente specificare l'indirizzo dei file in modo relativo. Ma relativo rispetto a cosa? Rispetto alla \emph{working directory} che definirà l'origine del nostro percorso.

Ma è facile immaginare che progetti diversi possano avere diverse \emph{working directory}. Infatti le cose stanno proprio in questo modo: per ciascun progetto dobbiamo specificare una diversa \emph{working directory}. Per esempio, potremmo avere un progetto relativo all'insegnamento di Psicometria e un progetto relativo alla prova finale.

Per organizzaere il lavoro in questo modo, si procede come segue. Supponiamo di creare una cartella chiamata \texttt{psicometria} che contiene, al suo interno, le cartelle \texttt{scripts} e \texttt{data}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{psicometria}\SpecialCharTok{/}
\NormalTok{  ├── data}
\NormalTok{  ├── scripts}
\end{Highlighting}
\end{Shaded}

Queste cartelle conterranno i file che ho specificato sopra.

Chiudiamo RStudio, se è aperto e lo riapriamo di nuovo. Dal menu selezioniamo \texttt{File\ -\textgreater{}\ New\ Project...} Questo aprirà un altro menu che ci chiederà, tra le altre cose se vogliamo creare un nuovo progetto (\texttt{New\ project}). Selezioniamo quell'opzione e navighiamo fino alla cartella \texttt{psicometria} e selezioniamo \texttt{open}. Questo creerà un file chiamato \texttt{psicometria.Rproj} nella cartella \texttt{psicometria}.

Chiudiamo RStudio. Se vogliamo accedere al progetto ``psicometria'' dobbiamo cliccare sul file \texttt{psicometria.Rproj}. Questo aprirà RStudio e farà in modo che la \emph{working directory} coincida con la cartalla \texttt{psicometria}. Ogni volta che vogliamo lavorare sui dati del progetto ``psicometria'' dobbiamo chiudere RStudio (se è già aperto) e riaprirlo cliccando sul file \texttt{psicometria.Rproj}.

A questo punto possiamo definire l'indirizzo dei file in modo relativo -- relativo alla cartella \texttt{psicometria}. Per fare questo usiamo le funzionalità del pacchetto \texttt{here}. Supponiamo di volere caricare un file di dati che si chiama \texttt{dati\_depressione.txt} e si trova nella cartella \texttt{data} contenuta nella cartella \texttt{psicometria}. Per importare questi dati (dopo avere caricato i pacchetti \texttt{rio} e \texttt{here}) useremo l'istruzione seguente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rio}\SpecialCharTok{::}\FunctionTok{import}\NormalTok{(}\FunctionTok{here}\NormalTok{(}\StringTok{"data"}\NormalTok{, }\StringTok{"dati\_depressione.txt"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

In altre parole, così facendo specifichiamo il percorso relativo del file \texttt{dati\_depressione.txt}. L'istruzione precedente significa che, partendo dalla cartella che coincide con la \emph{working directory} dobbiamo spostarci nella cartella \texttt{data} e lì dentro troviamo il file chiamato \texttt{dati\_depressione.txt}.

\hypertarget{manipolazione-dei-dati}{%
\section{Manipolazione dei dati}\label{manipolazione-dei-dati}}

\hypertarget{motivazione}{%
\subsection{Motivazione}\label{motivazione}}

Si chiamano ``dati grezzi'' quelli che provengono dal mondo circostanze, i
dati raccolti per mezzo degli strumenti usati negli esperimenti, per
mezzo di interviste, di questionari, ecc. Questi dati (chiamati
\emph{dataset}) raramente vengono forniti con una struttura logica precisa.
Per potere elaborarli mediante dei software dobbiamo prima trasformarli
in maniera tale che abbiano una struttura logica organizzata. La
struttura che solitamente si utilizza è quella tabellare (matrice dei
dati), ovvero si dispongono i dati in una tabella nella quale a ciascuna
riga corrisponde ad un'osservazione e ciascuna colonna corrisponde ad
una variabile rilevata. In \texttt{R} una tale struttura è chiamata \emph{data frame}.
Il pacchetto \texttt{dplyr}, che è al momento uno dei pacchetti più famosi e
utilizzati per la gestione dei dati, offre una serie di funzionalità che
consentono di ottenere il risultato descritto in precedenza e consente
inoltre di eseguire le operazioni più comuni di manipolazione dei dati
in maniera più semplice rispetto a quanto succeda quando usiamo le
funzioni base di \texttt{R}.

\hypertarget{trattamento-dei-dati-con-dplyr}{%
\subsection{\texorpdfstring{Trattamento dei dati con \texttt{dplyr}}{Trattamento dei dati con dplyr}}\label{trattamento-dei-dati-con-dplyr}}

Il pacchetto \texttt{dplyr} include cinque funzioni base: \texttt{filter()},
\texttt{select()}, \texttt{mutate()}, \texttt{arrange()} e \texttt{summarise()}. A queste cinque
funzioni di base si aggiungono il pipe \texttt{\%\textgreater{}\%} che serve a concatenare più
operazioni e \texttt{group\_by} che serve per il subsetting. In particolare,
considerando una matrice osservazioni per variabili, \texttt{select()} e
\texttt{mutate()} si occupano di organizzare le variabili, \texttt{filter()} e
\texttt{arrange()} i casi, e \texttt{summarise()} i gruppi.

Per introdurre le funzionalità di base di \texttt{dplyr}, considereremo i dati contenuti nel data frame \texttt{msleep} fornito dal pacchetto \texttt{ggplot2}, che elenca le ore di sonno medie per 83 specie di mammiferi \citep{savage2007scaling}. Carichiamo il pacchetto \texttt{tidyverse} (che contiene \texttt{ggplot2}) e leggiamo nella memoria di lavoro l'oggetto \texttt{msleep}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"tidyverse"}\NormalTok{)}
\FunctionTok{data}\NormalTok{(msleep)}
\FunctionTok{dim}\NormalTok{(msleep)}
\CommentTok{\#\textgreater{} [1] 83 11}
\end{Highlighting}
\end{Shaded}

\hypertarget{operatore-pipe}{%
\subsubsection{Operatore pipe}\label{operatore-pipe}}

Prima di presentare le funzionalità di \texttt{tidyverse}, introduciamo l'operatore pipe \texttt{\%\textgreater{}\%} del pacchetto \texttt{magrittr} -- ma ora presente anche in base \texttt{R} nella versione \texttt{\textbar{}\textgreater{}}. L'operatore pipe, \texttt{\%\textgreater{}\%} o \texttt{\textbar{}\textgreater{}}, serve a concatenare varie funzioni insieme, in modo da inserire un'operazione dietro l'altra. Una spiegazione intuitiva dell'operatore pipe è stata fornita in un tweet di \texttt{@andrewheiss}. Consideriamo la seguente istruzione in pseudo-codice \texttt{R}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{leave\_house}\NormalTok{(}\FunctionTok{get\_dressed}\NormalTok{(}\FunctionTok{get\_out\_of\_bed}\NormalTok{(}\FunctionTok{wake\_up}\NormalTok{(me, }\AttributeTok{time =} \StringTok{"8:00"}\NormalTok{), }\AttributeTok{side =} \StringTok{"correct"}\NormalTok{), }\AttributeTok{pants =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{shirt =} \ConstantTok{TRUE}\NormalTok{), }\AttributeTok{car =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{bike =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Il listato precedente descrive una serie di (pseudo) funzioni concatenate, le quali costituiscono gli argomenti di altre funzioni. Scritto così, il codice è molto difficile da capire. Possiamo però ottenere lo stesso risultato utilizzando l'operatore pipe che facilita la leggibilità del codice:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{me }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{wake\_up}\NormalTok{(}\AttributeTok{time =} \StringTok{"8:00"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{get\_out\_of\_bed}\NormalTok{(}\AttributeTok{side =} \StringTok{"correct"}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{get\_dressed}\NormalTok{(}\AttributeTok{pants =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{shirt =} \ConstantTok{TRUE}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{leave\_house}\NormalTok{(}\AttributeTok{car =} \ConstantTok{TRUE}\NormalTok{, }\AttributeTok{bike =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In questa seconda versione del (pseudo) codice \texttt{R} si capisce molto meglio ciò che vogliamo fare. Il data.frame \texttt{me} viene passato alla funzione \texttt{wake\_up()}. La funzione \texttt{wake\_up()} ha come argomento l'ora del giorno: \texttt{time\ =\ "8:00"}. Una volta ``svegliati'' (wake up) dobbiamo scendere dal letto. Quindi l'output di \texttt{wake\_up()} viene passato alla funzione \texttt{get\_out\_of\_bed()} la quale ha come argomento \texttt{side\ =\ "correct"} perché vogliamo scendere dal letto dalla parte giusta. E così via.

\hypertarget{selezionare-le-colonne-del-data.frame-con-select}{%
\subsubsection{\texorpdfstring{Selezionare le colonne del data.frame con \texttt{select()}}{Selezionare le colonne del data.frame con select()}}\label{selezionare-le-colonne-del-data.frame-con-select}}

Ritorniamo ora all'esempio precedente e supponiamo di volere selezionare le variabili \texttt{name}, \texttt{vore} e \texttt{sleep\_total} dal data.frame \texttt{msleep}. Per fare ciò usiamo funzione \texttt{select()} che consente di selezionare un sottoinsieme di variabili in un dataset. Usando pipe scriviamo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt }\OtherTok{\textless{}{-}}\NormalTok{ msleep }\SpecialCharTok{\%\textgreater{}\%}
\NormalTok{  dplyr}\SpecialCharTok{::}\FunctionTok{select}\NormalTok{(name, vore, sleep\_total)}
\NormalTok{dt}
\CommentTok{\#\textgreater{} \# A tibble: 83 x 3}
\CommentTok{\#\textgreater{}    name                       vore  sleep\_total}
\CommentTok{\#\textgreater{}    \textless{}chr\textgreater{}                      \textless{}chr\textgreater{}       \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{}  1 Cheetah                    carni        12.1}
\CommentTok{\#\textgreater{}  2 Owl monkey                 omni         17  }
\CommentTok{\#\textgreater{}  3 Mountain beaver            herbi        14.4}
\CommentTok{\#\textgreater{}  4 Greater short{-}tailed shrew omni         14.9}
\CommentTok{\#\textgreater{}  5 Cow                        herbi         4  }
\CommentTok{\#\textgreater{}  6 Three{-}toed sloth           herbi        14.4}
\CommentTok{\#\textgreater{}  7 Northern fur seal          carni         8.7}
\CommentTok{\#\textgreater{}  8 Vesper mouse               \textless{}NA\textgreater{}          7  }
\CommentTok{\#\textgreater{}  9 Dog                        carni        10.1}
\CommentTok{\#\textgreater{} 10 Roe deer                   herbi         3  }
\CommentTok{\#\textgreater{} \# ... with 73 more rows}
\end{Highlighting}
\end{Shaded}

laddove la sequenza di istruzioni precedenti significa che il data.frame \texttt{dt} è stato passato alla funzione \texttt{select()} contenuta nel pacchetto \texttt{dplyr}.

\hypertarget{filtrare-le-righe-del-data.frame-con-filter}{%
\subsubsection{\texorpdfstring{Filtrare le righe del data.frame con \texttt{filter()}}{Filtrare le righe del data.frame con filter()}}\label{filtrare-le-righe-del-data.frame-con-filter}}

La funzione \texttt{filter()} consente di selezionare un sottoinsieme di
osservazioni in un dataset. Per esempio, possiamo selezionare tutte le
osservazioni nella variabile \texttt{vore} contrassegnate come \texttt{carni} in
questo modo (ovvero, tutti i carnivori):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt }\SpecialCharTok{\%\textgreater{}\%}
\NormalTok{  dplyr}\SpecialCharTok{::}\FunctionTok{filter}\NormalTok{(vore }\SpecialCharTok{==} \StringTok{"carni"}\NormalTok{)}
\CommentTok{\#\textgreater{} \# A tibble: 19 x 3}
\CommentTok{\#\textgreater{}    name                       vore  sleep\_total}
\CommentTok{\#\textgreater{}    \textless{}chr\textgreater{}                      \textless{}chr\textgreater{}       \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{}  1 Cheetah                    carni        12.1}
\CommentTok{\#\textgreater{}  2 Northern fur seal          carni         8.7}
\CommentTok{\#\textgreater{}  3 Dog                        carni        10.1}
\CommentTok{\#\textgreater{}  4 Long{-}nosed armadillo       carni        17.4}
\CommentTok{\#\textgreater{}  5 Domestic cat               carni        12.5}
\CommentTok{\#\textgreater{}  6 Pilot whale                carni         2.7}
\CommentTok{\#\textgreater{}  7 Gray seal                  carni         6.2}
\CommentTok{\#\textgreater{}  8 Thick{-}tailed opposum       carni        19.4}
\CommentTok{\#\textgreater{}  9 Slow loris                 carni        11  }
\CommentTok{\#\textgreater{} 10 Northern grasshopper mouse carni        14.5}
\CommentTok{\#\textgreater{} 11 Tiger                      carni        15.8}
\CommentTok{\#\textgreater{} 12 Jaguar                     carni        10.4}
\CommentTok{\#\textgreater{} 13 Lion                       carni        13.5}
\CommentTok{\#\textgreater{} 14 Caspian seal               carni         3.5}
\CommentTok{\#\textgreater{} 15 Common porpoise            carni         5.6}
\CommentTok{\#\textgreater{} 16 Bottle{-}nosed dolphin       carni         5.2}
\CommentTok{\#\textgreater{} 17 Genet                      carni         6.3}
\CommentTok{\#\textgreater{} 18 Arctic fox                 carni        12.5}
\CommentTok{\#\textgreater{} 19 Red fox                    carni         9.8}
\end{Highlighting}
\end{Shaded}

\hypertarget{aggiungere-una-colonna-al-data.frame-con-mutate}{%
\subsubsection{\texorpdfstring{Aggiungere una colonna al data.frame con \texttt{mutate()}}{Aggiungere una colonna al data.frame con mutate()}}\label{aggiungere-una-colonna-al-data.frame-con-mutate}}

Talvolta vogliamo creare una nuova variabile in uno stesso dataset ad
esempio sommando o dividendo due variabili, oppure calcolandone la
media. A questo scopo si usa la funzione \texttt{mutate()}. Per esempio, se
vogliamo esprimere i valori di \texttt{sleep\_total} in minuti, moltiplichiamo
per 60:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}\AttributeTok{sleep\_minutes =}\NormalTok{ sleep\_total }\SpecialCharTok{*} \DecValTok{60}\NormalTok{) }\SpecialCharTok{\%\textgreater{}\%}
\NormalTok{  dplyr}\SpecialCharTok{::}\FunctionTok{select}\NormalTok{(sleep\_total, sleep\_minutes)}
\CommentTok{\#\textgreater{} \# A tibble: 83 x 2}
\CommentTok{\#\textgreater{}    sleep\_total sleep\_minutes}
\CommentTok{\#\textgreater{}          \textless{}dbl\textgreater{}         \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{}  1        12.1           726}
\CommentTok{\#\textgreater{}  2        17            1020}
\CommentTok{\#\textgreater{}  3        14.4           864}
\CommentTok{\#\textgreater{}  4        14.9           894}
\CommentTok{\#\textgreater{}  5         4             240}
\CommentTok{\#\textgreater{}  6        14.4           864}
\CommentTok{\#\textgreater{}  7         8.7           522}
\CommentTok{\#\textgreater{}  8         7             420}
\CommentTok{\#\textgreater{}  9        10.1           606}
\CommentTok{\#\textgreater{} 10         3             180}
\CommentTok{\#\textgreater{} \# ... with 73 more rows}
\end{Highlighting}
\end{Shaded}

\hypertarget{ordinare-i-dati-con-arrange}{%
\subsubsection{\texorpdfstring{Ordinare i dati con \texttt{arrange()}}{Ordinare i dati con arrange()}}\label{ordinare-i-dati-con-arrange}}

La funzione \texttt{arrange()} serve a ordinare i dati in base ai valori di una
o più variabili. Per esempio, possiamo ordinare la variabile
\texttt{sleep\_total} dal valore più alto al più basso in questo modo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{arrange}\NormalTok{(}\FunctionTok{desc}\NormalTok{(sleep\_total))}
\CommentTok{\#\textgreater{} \# A tibble: 83 x 3}
\CommentTok{\#\textgreater{}    name                           vore    sleep\_total}
\CommentTok{\#\textgreater{}    \textless{}chr\textgreater{}                          \textless{}chr\textgreater{}         \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{}  1 Little brown bat               insecti        19.9}
\CommentTok{\#\textgreater{}  2 Big brown bat                  insecti        19.7}
\CommentTok{\#\textgreater{}  3 Thick{-}tailed opposum           carni          19.4}
\CommentTok{\#\textgreater{}  4 Giant armadillo                insecti        18.1}
\CommentTok{\#\textgreater{}  5 North American Opossum         omni           18  }
\CommentTok{\#\textgreater{}  6 Long{-}nosed armadillo           carni          17.4}
\CommentTok{\#\textgreater{}  7 Owl monkey                     omni           17  }
\CommentTok{\#\textgreater{}  8 Arctic ground squirrel         herbi          16.6}
\CommentTok{\#\textgreater{}  9 Golden{-}mantled ground squirrel herbi          15.9}
\CommentTok{\#\textgreater{} 10 Tiger                          carni          15.8}
\CommentTok{\#\textgreater{} \# ... with 73 more rows}
\end{Highlighting}
\end{Shaded}

\hypertarget{raggruppare-i-dati-con-group_by}{%
\subsubsection{\texorpdfstring{Raggruppare i dati con \texttt{group\_by()}}{Raggruppare i dati con group\_by()}}\label{raggruppare-i-dati-con-group_by}}

La funzione \texttt{group\_by()} serve a raggruppare insieme i valori in base a
una o più variabili. La vedremo in uso in seguito insieme a
\texttt{summarise()}.

\hypertarget{sommario-dei-dati-con-summarise}{%
\subsubsection{\texorpdfstring{Sommario dei dati con \texttt{summarise()}}{Sommario dei dati con summarise()}}\label{sommario-dei-dati-con-summarise}}

La funzione \texttt{summarise()} collassa il dataset in una singola riga dove
viene riportato il risultato della statistica richiesta. Per esempio, la
media del tempo totale del sonno è

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarise}\NormalTok{(}
    \AttributeTok{m\_sleep =} \FunctionTok{mean}\NormalTok{(sleep\_total, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{)}
\NormalTok{  ) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{unlist}\NormalTok{()}
\CommentTok{\#\textgreater{}  m\_sleep }
\CommentTok{\#\textgreater{} 10.43373}
\end{Highlighting}
\end{Shaded}

\hypertarget{operazioni-raggruppate}{%
\subsubsection{Operazioni raggruppate}\label{operazioni-raggruppate}}

In precedenza abbiamo visto come i mammiferi considerati dormano, in
media, 10.4 ore al giorno. Troviamo ora il sonno medio in funzione di
\texttt{vore}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{group\_by}\NormalTok{(vore) }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{summarise}\NormalTok{(}
    \AttributeTok{m\_sleep =} \FunctionTok{mean}\NormalTok{(sleep\_total, }\AttributeTok{na.rm =} \ConstantTok{TRUE}\NormalTok{),}
    \AttributeTok{n =} \FunctionTok{n}\NormalTok{()}
\NormalTok{  )}
\CommentTok{\#\textgreater{} \# A tibble: 5 x 3}
\CommentTok{\#\textgreater{}   vore    m\_sleep     n}
\CommentTok{\#\textgreater{}   \textless{}chr\textgreater{}     \textless{}dbl\textgreater{} \textless{}int\textgreater{}}
\CommentTok{\#\textgreater{} 1 carni     10.4     19}
\CommentTok{\#\textgreater{} 2 herbi      9.51    32}
\CommentTok{\#\textgreater{} 3 insecti   14.9      5}
\CommentTok{\#\textgreater{} 4 omni      10.9     20}
\CommentTok{\#\textgreater{} 5 \textless{}NA\textgreater{}      10.2      7}
\end{Highlighting}
\end{Shaded}

Si noti che, nel caso di 7 osservazioni, il valore di \texttt{vore} non era
specificato. Per tali osservazioni, dunque, la classe di appartenenza è
\texttt{NA}.

\hypertarget{dati-categoriali-in-r}{%
\subsection{\texorpdfstring{Dati categoriali in \texttt{R}}{Dati categoriali in R}}\label{dati-categoriali-in-r}}

Consideriamo una variabile che descrive il genere e include le categorie \texttt{male}, \texttt{female} e \texttt{non-conforming}. In \texttt{R}, ci sono due modi per memorizzare queste informazioni. Uno è usare la classe \emph{character strings} e l'altro è usare la classe \emph{factor}. Non ci addentrimo qui nelle sottigliezze di questa distinzione, motivata in gran parte per le necessità della programmazione con le funzioni di \texttt{tidyverse}. Per gli scopi di questo insegnamento sarà sufficiente codificare le variabili qualitative usando la classe \emph{factor}. Una volta codificati i dati qualitativi utilizzando la classe \emph{factor}, si pongono spesso due problemi:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  modificare le etichette dei livelli (modalità) di un fattore,
\item
  riordinare i livelli di un fattore.
\end{enumerate}

\hypertarget{modificare-le-etichette-dei-livelli-di-un-fattore}{%
\subsubsection{Modificare le etichette dei livelli di un fattore}\label{modificare-le-etichette-dei-livelli-di-un-fattore}}

Esaminiamo l'esempio seguente.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f\_1 }\OtherTok{\textless{}{-}} \FunctionTok{c}\NormalTok{(}\StringTok{"old\_3"}\NormalTok{, }\StringTok{"old\_4"}\NormalTok{, }\StringTok{"old\_1"}\NormalTok{, }\StringTok{"old\_1"}\NormalTok{, }\StringTok{"old\_2"}\NormalTok{)}
\NormalTok{f\_1 }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(f\_1)}
\NormalTok{y }\OtherTok{\textless{}{-}} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}
\NormalTok{df }\OtherTok{\textless{}{-}} \FunctionTok{data.frame}\NormalTok{(f\_1, y)}
\NormalTok{df}
\CommentTok{\#\textgreater{}     f\_1 y}
\CommentTok{\#\textgreater{} 1 old\_3 1}
\CommentTok{\#\textgreater{} 2 old\_4 2}
\CommentTok{\#\textgreater{} 3 old\_1 3}
\CommentTok{\#\textgreater{} 4 old\_1 4}
\CommentTok{\#\textgreater{} 5 old\_2 5}
\end{Highlighting}
\end{Shaded}

Supponiamo di volere che i livelli del fattore \texttt{f\_1} abbiano le etichette \texttt{new\_1}, \texttt{new\_2}, ecc. Per ottenere questo risultato usiamo la funzione \texttt{recode()} di \texttt{dplyr}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df }\OtherTok{\textless{}{-}}\NormalTok{ df }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{mutate}\NormalTok{(}
    \AttributeTok{f\_1 =}
\NormalTok{      dplyr}\SpecialCharTok{::}\FunctionTok{recode}\NormalTok{(f\_1,}
        \StringTok{"old\_1"} \OtherTok{=} \StringTok{"new\_poco"}\NormalTok{,}
        \StringTok{"old\_2"} \OtherTok{=} \StringTok{"new\_medio"}\NormalTok{,}
        \StringTok{"old\_3"} \OtherTok{=} \StringTok{"new\_tanto"}\NormalTok{,}
        \StringTok{"old\_4"} \OtherTok{=} \StringTok{"new\_massimo"}\NormalTok{,}
\NormalTok{      )}
\NormalTok{  )}
\NormalTok{df}
\CommentTok{\#\textgreater{}           f\_1 y}
\CommentTok{\#\textgreater{} 1   new\_tanto 1}
\CommentTok{\#\textgreater{} 2 new\_massimo 2}
\CommentTok{\#\textgreater{} 3    new\_poco 3}
\CommentTok{\#\textgreater{} 4    new\_poco 4}
\CommentTok{\#\textgreater{} 5   new\_medio 5}
\end{Highlighting}
\end{Shaded}

\hypertarget{riordinare-i-livelli-di-un-fattore}{%
\subsubsection{Riordinare i livelli di un fattore}\label{riordinare-i-livelli-di-un-fattore}}

Spesso i livelli dei fattori hanno un ordinamento naturale. Tuttavia, l'impostazione predefinita in base \texttt{R} è ordinare i livelli in ordine alfabetico. Quindi, gli utenti devono avere un modo per imporre l'ordine desiderato sulla codifica delle loro variabili qualitative. Ciò può essere ottenuto nel modo seguente.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df}\SpecialCharTok{$}\NormalTok{f\_1 }\OtherTok{\textless{}{-}} \FunctionTok{factor}\NormalTok{(df}\SpecialCharTok{$}\NormalTok{f\_1,}
  \AttributeTok{levels =} \FunctionTok{c}\NormalTok{(}
    \StringTok{"new\_poco"}\NormalTok{, }\StringTok{"new\_medio"}\NormalTok{, }\StringTok{"new\_tanto"}\NormalTok{, }\StringTok{"new\_massimo"}
\NormalTok{  )}
\NormalTok{)}
\FunctionTok{summary}\NormalTok{(df}\SpecialCharTok{$}\NormalTok{f\_1)}
\CommentTok{\#\textgreater{}    new\_poco   new\_medio   new\_tanto new\_massimo }
\CommentTok{\#\textgreater{}           2           1           1           1}
\end{Highlighting}
\end{Shaded}

Per approfondire le problematiche della manipolazione di variabili qualitative in R, si veda \citet{mcnamara2018wrangling}.

\hypertarget{creare-grafici-con-ggplot2}{%
\subsection{\texorpdfstring{Creare grafici con \texttt{ggplot2()}}{Creare grafici con ggplot2()}}\label{creare-grafici-con-ggplot2}}

Il pacchetto \texttt{ggplot2()} è un potente strumento per rappresentare graficamente i dati. Le iniziali del nome, \texttt{gg}, si riferiscono alla ``Grammar of Graphics'', che è un modo di pensare le figure come una serie di layer stratificati. Originariamente descritta da \citet{wilkinson2012grammar}, la grammatica dei grafici è stata aggiornata e applicata in R da Hadley Wickham, il creatore del pacchetto.

La funzione da cui si parte per inizializzare un grafico è \texttt{ggplot()}. La funzione \texttt{ggplot()} richiede due argomenti. Il primo è l'oggetto di tipo data.frame che contiene i dati da visualizzare -- in alternativa al primo argomento, un dataframe può essere passato a \texttt{ggplot()} mediante l'operatore pipe. Il secondo è una particolare lista che viene generata dalla funzione \texttt{aes()}, la quale determina l'aspetto (\emph{aesthetic}) del grafico. La funzione \texttt{aes()} richiede necessariamente di specificare ``x'' e ``y'', ovvero i nomi delle colonne del data.frame che è stato utilizzato quale primo argomento di \texttt{ggplot()} (o che è stato passato da pipe), le quali rappresentano le variabili da porre rispettivamente sugli assi orizzontale e verticale.

La definizione della tipologia di grafico e i vari parametri sono poi definiti successivamente, aggiungendo all'oggetto creato da \texttt{ggplot()} tutte le componenti necessarie. Saranno quindi altre funzioni, come \texttt{geom\_bar()}, \texttt{geom\_line()} o \texttt{geom\_point()} a occuparsi di aggiungere al livello di base barre, linee, punti, e così via. Infine, tramite altre funzioni, ad esempio \texttt{labs()}, sarà possibile definire i dettagli più fini.

Gli elementi grafici (bare, punti, segmenti, \ldots) usati da \texttt{ggplot2} sono chiamati \texttt{geoms}. Mediante queste funzioni è possibile costruire diverse tipologie di grafici:

\begin{itemize}
\item
  \texttt{geom\_bar()}: crea un layer con delle barre;
\item
  \texttt{geom\_point()}: crea un layer con dei punti (diagramma a dispersione);
\item
  \texttt{geom\_line()}: crea un layer con una linea retta;
\item
  \texttt{geom\_histogram()}: crea un layer con un istogramma;
\item
  \texttt{geom\_boxplot()}: crea un layer con un box-plot;
\item
  \texttt{geom\_errorbar()}: crea un layer con barre che rappresentano intervalli di confidenza;
\item
  \texttt{geom\_hline()} e \texttt{geom\_vline()} : crea un layer con una linea orizzontale o verticale definita dall'utente.
\end{itemize}

Un comando generico ha la seguente forma:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_graph }\OtherTok{\textless{}{-}}\NormalTok{ my\_data }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}\FunctionTok{aes}\NormalTok{(x\_var, y\_var)) }\SpecialCharTok{+}
  \FunctionTok{geom\_...}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

La prima volta che si usa il pacchetto \texttt{ggplot2} è necessario installarlo. Per fare questo possiamo installare \texttt{tidyverse} che, oltre a caricare \texttt{ggplot2}, carica anche altre utili funzioni per l'analisi dei dati:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{install.packages}\NormalTok{(}\StringTok{"tidyverse"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Per attivare il pacchetto si usa l'istruzione:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{library}\NormalTok{(}\StringTok{"tidyverse"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Ogni volta che si inizia una sessione R è necessario attivare i pacchetti che si vogliono usare, ma non è necessario istallarli una nuova volta. Se è necessario specificare il pacchetto nel quale è contenuta la funzione (o il data.frame) che vogliamo utilizzare, usiamo la sintassi \texttt{package::function()}. Per esempio, l'istruzione \texttt{ggplot2::ggplot()} rende esplicito che stiamo usando la funzione \texttt{ggplot()} contenuta nel pacchetto \texttt{ggplot2}.

\hypertarget{diagramma-a-dispersione}{%
\subsection{Diagramma a dispersione}\label{diagramma-a-dispersione}}

Consideriamo nuovamenti i dati contenuti nel data frame \texttt{msleep} e poniamoci il problema di rappresentare graficamente la relazione tra il numero medio di ore di sonno giornaliero (\texttt{sleep\_total}) e il peso dell'animale (\texttt{bodywt}). Usando le impostazioni di default di \texttt{ggplot2}, con le istruzioni seguenti, otteniamo il grafico fornito dalla figura seguente.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{data}\NormalTok{(msleep)}
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ msleep }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}
    \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ bodywt, }\AttributeTok{y =}\NormalTok{ sleep\_total)}
\NormalTok{  ) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\FunctionTok{print}\NormalTok{(p)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{928_R_tidyverse_files/figure-latex/unnamed-chunk-17-1} \end{center}

Coloriamo ora in maniera diversa i punti che rappresentano animali carnivori, erbivori, ecc.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ msleep }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}
    \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =}\NormalTok{ bodywt, }\AttributeTok{y =}\NormalTok{ sleep\_total, }\AttributeTok{col =}\NormalTok{ vore)}
\NormalTok{  ) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\FunctionTok{print}\NormalTok{(p)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{928_R_tidyverse_files/figure-latex/unnamed-chunk-18-1} \end{center}

È chiaro, senza fare alcuna analisi statistica, che la relazione tra le due variabili non è lineare. Trasformando in maniera logaritmica i valori dell'asse \(x\) la relazione si linearizza.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OtherTok{\textless{}{-}}\NormalTok{ msleep }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}
    \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =} \FunctionTok{log}\NormalTok{(bodywt), }\AttributeTok{y =}\NormalTok{ sleep\_total, }\AttributeTok{col =}\NormalTok{ vore)}
\NormalTok{  ) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{()}
\FunctionTok{print}\NormalTok{(p)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{928_R_tidyverse_files/figure-latex/unnamed-chunk-19-1} \end{center}

Infine, aggiustiamo il ``tema'' del grafico, aggiungiamo le etichette sugli assi e il titolo.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{msleep }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}
    \FunctionTok{aes}\NormalTok{(}\AttributeTok{x =} \FunctionTok{log}\NormalTok{(bodywt), }\AttributeTok{y =}\NormalTok{ sleep\_total, }\AttributeTok{col =}\NormalTok{ vore)}
\NormalTok{  ) }\SpecialCharTok{+}
  \FunctionTok{geom\_point}\NormalTok{(}\AttributeTok{size =} \DecValTok{2}\NormalTok{) }\SpecialCharTok{+}
  \FunctionTok{theme}\NormalTok{(}\AttributeTok{legend.title =} \FunctionTok{element\_blank}\NormalTok{()) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}
    \AttributeTok{x =} \StringTok{"Log Peso Corporeo"}\NormalTok{,}
    \AttributeTok{y =} \StringTok{"Totale Ore di Sonno"}\NormalTok{,}
    \AttributeTok{title =} \StringTok{"Il sonno in 83 specie di mammiferi"}\NormalTok{,}
    \AttributeTok{subtitle =} \StringTok{"Savage e West (2007)"}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{928_R_tidyverse_files/figure-latex/unnamed-chunk-20-1} \end{center}

\hypertarget{istogramma}{%
\subsubsection{Istogramma}\label{istogramma}}

Creiamo ora un istogramma che rappresenta la distribuzione del (logaritmo del) peso medio del cervello delle 83 specie di mammiferi considerate da \citet{savage2007quantitative}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{msleep }\SpecialCharTok{\%\textgreater{}\%}
  \FunctionTok{ggplot}\NormalTok{(}
    \FunctionTok{aes}\NormalTok{(}\FunctionTok{log}\NormalTok{(brainwt))}
\NormalTok{  ) }\SpecialCharTok{+}
  \FunctionTok{geom\_histogram}\NormalTok{(}\FunctionTok{aes}\NormalTok{(}\AttributeTok{y =}\NormalTok{ ..density..)) }\SpecialCharTok{+}
  \FunctionTok{labs}\NormalTok{(}
    \AttributeTok{x =} \StringTok{"Log Peso Cervello"}\NormalTok{,}
    \AttributeTok{y =} \StringTok{"Frequenza Relativa"}
\NormalTok{  ) }\SpecialCharTok{+}
  \FunctionTok{theme}\NormalTok{(}\AttributeTok{legend.title =} \FunctionTok{element\_blank}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{928_R_tidyverse_files/figure-latex/unnamed-chunk-21-1} \end{center}

L'argomento \texttt{aes(y=..density..)} in \texttt{geom\_histogram()} produce le frequenze relative. L'opzione di default (senza questo argomento) porta \texttt{ggplot()} a rappresentare le frequenze assolute.

\hypertarget{scrivere-il-codice-in-r-con-stile}{%
\subsection{\texorpdfstring{Scrivere il codice in \texttt{R} con stile}{Scrivere il codice in R con stile}}\label{scrivere-il-codice-in-r-con-stile}}

Uno stile di programmazione è un insieme di regole per la gestione dell'indentazione dei blocchi di codice, per la creazione dei nomi dei file e delle variabili e per le convenzioni tipografiche che vengono usate. Scrivere il codice in \texttt{R} con stile consente di creare listati più leggibili e semplici da modificare, minimizza la possibilità di errore, e consente correzioni e modifiche più rapide. Vi sono molteplici stili di programmazione che possono essere utilizzati dall'utente, anche se è bene attenersi a quelle che sono le convenzioni maggiormente diffuse, allo scopo di favorire la comunicazione. In ogni caso, l'importante è di essere coerenti, ovvero di adottare le stesse convenzioni in tutte le parti del codice che si scrive. Ad esempio, se si sceglie di usare lo stile \texttt{snake\_case} per il nome composto di una variabile (es., \texttt{personality\_trait}), non è appropriato usare lo stile \emph{lower Camel case} per un'altra variabile (es., \texttt{socialStatus}). Dato che questo argomento è stato trattato ampiamente in varie sedi, mi limito qui a rimandare ad uno stile di programmazione molto popolare, quello proposto da Hadley Wickham, il creatore di \texttt{tidyverse}. Potete trovare maggiori informazioni al seguente link: \url{http://style.tidyverse.org/}.

\hypertarget{flusso-di-lavoro-riproducibile}{%
\section{Flusso di lavoro riproducibile}\label{flusso-di-lavoro-riproducibile}}

\hypertarget{la-crisi-della-riproducibilituxe0}{%
\subsection{La crisi della riproducibilità}\label{la-crisi-della-riproducibilituxe0}}

\begin{quote}
Per il metodo scientifico è essenziale che gli esperimenti siano riproducibili. Vale a dire che una persona diversa dallo sperimentatore originale deve essere in grado di ottenere gli stessi risultati seguendo lo stesso protocollo sperimentale. (Gilbert Chin)
\end{quote}

Ma in psicologia (e non solo) la riproducibilità è inferiore a quanto previsto o desiderato. In un famoso studio pubblicato su \emph{Science}, un ampio gruppo di ricercatori \citep{open2015estimating} è riuscito a replicare solo il 40 per cento circa dei risultati di 100 studi di psicologia cognitiva e sociale pubblicati in precedenza. I risultati di questo studio, e di molti altri pubblicati in seguito, sono stati interpretati in modi diversi. La preoccupazione sulla riproducibilità della ricerca è stata espressa mediante l'affermare secondo la quale ``la maggior parte dei risultati della ricerca sono falsi'' \citep{ioannidis2005most} oppure mediante l'affermazione secondo cui ``dobbiamo apportare modifiche sostanziali al modo in cui conduciamo la ricerca'' \citep{cumming2014new}. Alcuni ricercatori sono arrivati a definire la presente situazione come una ``crisi della riproducibilità dei risultati della ricerca''.

Il termine ``riproducibilità'' (o ``replicabilità'') è stato definito in vari modi. Consideriamo la definizione fornita da \citet{goodman2016does}:

\begin{itemize}
\item
  la riproducibilità dei metodi ``si riferisce al fatto che il ricercatore fornisce dettagli sufficienti sulle procedure e sui dati dello studio in modo che le stesse procedure possano \ldots{} essere replicate esattamente'' (pag. 2) con gli stessi dati;
\item
  la riproducibilità dei risultati ``si riferisce all'ottenimento degli stessi risultati dalla conduzione di uno studio indipendente le cui procedure replicano il più esattamente possibile quelle dell'esperimento originale'' (pag. 2-3) con dati indipendenti;
\item
  la riproducibilità inferenziale ``si riferisce alla possibilità di trarre conclusioni qualitativamente simili da una replica indipendente di uno studio o da una nuova analisi dello studio originale'' (pag. 4).
\end{itemize}

Per gli scopi presenti, ci focalizzeremo qui sulla riproducibilità dei metodi. Cioè, discuteremo di come \texttt{R} può aiutarci a migliorare questo aspetto della riproducibilità. In questo capitolo mostreremo come R possa essere utilizzato all'interno di un flusso di lavoro (\emph{workflow}) riproducibile che integra (1) il codice di analisi dei dati, (2) i dati medesimi e (3) il testo della relazione che comunica i risultati dello studio. A tal fine utilizzeremo due pacchetti R: \texttt{rmarkdown} e \texttt{knitr}. Questi pacchetti consentono di unire il codice R ad un linguaggio di marcatura (o di markup) chiamato Markdown. Il linguaggio di markup Markdown sta diventando sempre più popolare e viene usato, oltre che per creare \href{https://avehtari.github.io/ROS-Examples/Simplest/simplest.html}{reports} di analisi di dati, anche per creare \href{https://alison.rbind.io}{siti web}, \href{https://djnavarro.net}{blog}, \href{https://r4ds.had.co.nz}{libri}, \href{https://osf.io/9te8p/}{articoli accademici}, \href{https://github.com/mitchelloharawild/vitae}{curriculum vitae}, \href{https://rmarkdown.rstudio.com/lesson-11.html}{slide}, \href{https://github.com/ismayc/thesisdown}{tesi di laurea}. Per esempio, il presente sito web è stato scritto usando R-markdown.

\hypertarget{r-markdown}{%
\subsection{R-markdown}\label{r-markdown}}

Un linguaggio di markup permette di aggiungere mediante marcatori (tag) informazioni sulla struttura e sulla formattazione da applicare ad un documento. Un'introduzione al linguaggio Markdown può essere trovata, per esempio, \href{https://rmarkdown.rstudio.com/authoring_pandoc_markdown.html}{qui} oppure \href{https://experienceleague.adobe.com/docs/contributor/contributor-guide/writing-essentials/markdown.html?lang=it\#estensioni-personalizzate-markdown}{qui}.

In questo capitolo ci focalizzeremo però sugli aspetti più importanti di R-markdown che permette di costruire documenti in cui combinare testo formattato (quindi non solo commenti ma anche formule, titoli etc) e istruzioni codice (\texttt{R} e non solo) con i corrispettivi output. Informazioni dettagliate su R-markdown sono disponibili \href{https://bookdown.org/yihui/rmarkdown/}{qui} e \href{https://bookdown.org/yihui/rmarkdown-cookbook/}{qui}.

Un file R-markdown è composto da tre tipi di oggetti:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  header in formato \texttt{YAML} delimitato da \texttt{-\/-\/-},
\item
  testo in formato \texttt{markdown},
\item
  blocchi (``chunks'') di codice \texttt{R}, delimitati da tre apici.
\end{enumerate}

\hypertarget{header}{%
\subsubsection{Header}\label{header}}

L'intestazione di un documento \texttt{.Rmd} (R-markdown) corrisponde al cosiddetto \emph{YAML header} (un acronimo che significa \emph{Yet Another Markup Language}). Lo YAML header controlla le caratteristiche generali del documento, incluso il tipo di documento che viene prodotto (un documento HTML che può essere visualizzato su tutti i principali browser, un documento Microsoft Word o un PDF se abbiamo installato LaTeX sul nostro computer), la dimensione del carattere, lo stile, il titolo, l'autore, ecc. Nello YAML header (a differenza del codice \texttt{R}) è necessario rispettare la spaziatura prestabilita delle istruzioni che vengono elencate. Gli elementi principali sono \texttt{title:}, \texttt{author:}, \texttt{output:}.

L'argomento di \texttt{output:} è dove diciamo a R-markdown quale tipo di file vogliamo che venga prodotto. Il tipo più flessibile, che non richiede alcuna configurazione, è \texttt{html\_document}.

\hypertarget{testo}{%
\subsubsection{Testo}\label{testo}}

Alla conclusione dello YAML header inizia il documento R-markdown. Da questo punto in poi possiamo utilizzare testo normale, codice \texttt{R} e sintassi Markdown per controllare cosa viene mostrato e come.

\hypertarget{formattazione}{%
\subsubsection{Formattazione}\label{formattazione}}

È possibile contrassegnare intestazioni, grassetto e corsivo come indicato di seguito.

\begin{verbatim}
# Intestazione 1
## Intestazione 2
### Intestazione 3
#### Intestazione 4
##### Intestazione 5
###### Intestazione 6

Questo è un testo normale.
Possiamo scrivere in **grassetto** il testo usando due asterischi.
Possiamo scrivere in *corsivo* usando un asterisco.

>Questa è un’**area rientrata**.

Questa riga invece non è più rientrata.
\end{verbatim}

\hypertarget{elenchi}{%
\subsubsection{Elenchi}\label{elenchi}}

Per creare un elenco puntato si utilizza il segno più, il trattino o l'asterisco. Tutte le tre soluzioni portano allo stesso risultato.

\begin{verbatim}
- Punto 1 della lista
- Punto 2 della lista
- Punto 3 della lista
\end{verbatim}

Un elenco numerato, invece, si crea con un numero seguito da un punto.

\begin{verbatim}
1. Punto 1 della lista
2. Punto 2 della lista
3. Punto 3 della lista
\end{verbatim}

\hypertarget{hyperlink}{%
\subsubsection{Hyperlink}\label{hyperlink}}

Per inserire un hyperlink ci sono due metodi:

\begin{itemize}
\tightlist
\item
  specificare solo il percorso \texttt{\textless{}http://rmarkdown.rstudio.com\textgreater{}}, \url{http://rmarkdown.rstudio.com}\\
\item
  creare un \href{http://rmarkdown.rstudio.com}{link} con \texttt{{[}link{]}(http://rmarkdown.rstudio.com)}\\
\end{itemize}

\hypertarget{immagini}{%
\subsubsection{Immagini}\label{immagini}}

Per inserire un'immagine la sintassi è molto simile: \texttt{!{[}Esempio\ di\ immagine\ inserita\ in\ un\ documento\ R-markdown.{]}(images/hex-rmarkdown.png)\{width=20\%\}}:

\begin{figure}
\centering
\includegraphics[width=0.2\textwidth,height=\textheight]{images/hex-rmarkdown.png}
\caption{Esempio di immagine inserita in un documento R-markdown.}
\end{figure}

\hypertarget{codice-inline}{%
\subsubsection{Codice inline}\label{codice-inline}}

Per contrassegnare un'area di testo come codice, markdown utilizza il cosiddetto backtick, noto anche come gravis o accento grave, da non confondere con la virgoletta singola. La marcatura prevede un accento all'inizio e uno alla fine dell'area di testo corrispondente.

\begin{verbatim}
Questo è `codice`.
\end{verbatim}

\hypertarget{equazioni}{%
\subsubsection{Equazioni}\label{equazioni}}

Equazioni possono essere inserite in un documento R-markdown usando la sintassi \LaTeX. Qualsiasi cosa all'interno del segno di dollaro \$ viene trattata come un'equazione ``inline''. Qualunque cosa all'interno di due segni di dollaro \$\$ viene trattata come un'equazione a sé stante.

Per esempio, questa è la formula della distribuzione Normale espressa in notazione LaTeX e riprodotta all'interno di un documento R-markdown:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{f}\NormalTok{(x) }\OtherTok{=}\NormalTok{ \textbackslash{}frac\{}\DecValTok{1}\NormalTok{\}\{\textbackslash{}sigma\textbackslash{}sqrt\{}\DecValTok{2}\NormalTok{\textbackslash{}pi\}\}}
\NormalTok{  \textbackslash{}exp\textbackslash{}}\FunctionTok{left}\NormalTok{( }\SpecialCharTok{{-}}\NormalTok{\textbackslash{}frac\{}\DecValTok{1}\NormalTok{\}\{}\DecValTok{2}\NormalTok{\}\textbackslash{}}\FunctionTok{left}\NormalTok{(\textbackslash{}frac\{x}\SpecialCharTok{{-}}\NormalTok{\textbackslash{}mu\}\{\textbackslash{}sigma\}\textbackslash{}right)}\SpecialCharTok{\^{}}\NormalTok{\{\textbackslash{}}\SpecialCharTok{!}\DecValTok{2}\NormalTok{\}\textbackslash{},\textbackslash{}right)}
\end{Highlighting}
\end{Shaded}

\[
f(x) = \frac{1}{\sigma\sqrt{2\pi}}
  \exp\left( -\frac{1}{2}\left(\frac{x-\mu}{\sigma}\right)^{\!2}\,\right)
\]

\hypertarget{codice-r}{%
\subsubsection{Codice R}\label{codice-r}}

In un documento R-markdown istruzioni di codice vengono inserite in blocchi delimitati da tre apici. Ciò consente di valutare il codice all'interno del documento e di produrre un output che verrà stampato nel documento stesso. Possiamo dunque stampare tabelle e figure prodotti direttamente dal codice \texttt{R}. Ciò significa inoltre, che se qualcosa cambia nei dati o nelle analisi dei dati, le tabelle e le figure si aggiorneranno automaticamente.

Un chunk \texttt{R} viene valutato proprio come il normale codice \texttt{R}, quindi si applica tutto ciò che abbiamo imparato nei capitoli precedenti. Se il chunk \texttt{R} produce un output, questo output verrà visualizzato nel documento.

\hypertarget{compilare-la-presentazione-r-markdown}{%
\subsection{Compilare la presentazione R-markdown}\label{compilare-la-presentazione-r-markdown}}

Ma dove si trova questo magico documento che include il testo e l'output prodotto dal codice \texttt{R}? Ottima domanda. Siamo stati abituati ai programmi di videoscrittura (come Microsoft Word) che si conformano al cosiddetto stile ``WYSIWYG'' (What You See Is What You Get) -- cioè, si vede come apparirà il documento stampato mentre lo si digita. Questo può avere alcuni vantaggi ma può anche essere molto limitante. R-Markdown, d'altra parte, funziona in modo diverso. Ovvero, deve essere ``compilato'' (knitted) per passare dal file sorgente al documento formattato. In RStudio, tale operazione è semplice: c'è un pulsante in alto a sinistra nel pannello di scripting di un documento \texttt{.Rmd}. È sufficiente selezionare tale pulsante e il nostro documento verrà creato.

È importante notare che il codice del documento deve essere autonomo. Ciò significa che tutto ciò che vogliamo che venga eseguito deve essere incluso nel documento, indipendentemente da ciò che era già stato eseguito al di fuori di esso. Ad esempio, è perfettamente legittimo (e anche molto utile) testare il codice \texttt{R} al di fuori del documento \texttt{Rmd}. Tuttavia, quando compiliamo il documento \texttt{Rmd}, tutto ciò che è stato fatto al di fuori del documento \texttt{Rmd} viene dimenticato. Ciò consente di creare un documento autosufficiente che favorisce la riproducibilità dei metodi di analisi dei dati: utilizzando uno specifico documento \texttt{Rmd} con un campione di dati si giunge sempre allo stesso risultato e alla stessa interpretazione. Ciò non è invece vero se si utilizza un software con un interfaccia point-and-click.

\hypertarget{dati-mancanti-1}{%
\section{Dati mancanti}\label{dati-mancanti-1}}

\hypertarget{motivazione-1}{%
\subsection{Motivazione}\label{motivazione-1}}

La pulizia dei dati (\emph{data cleaning}) in \texttt{R} è fondamentale per effettuare qualsiasi analisi. Uno degli aspetti più importanti della pulizia dei dati è la gestione dei dati mancanti. I valori mancanti (\emph{missing values}) vengono indicati dal codice \texttt{NA}, che significa \emph{not available} --- non disponibile.

\hypertarget{trattamento-dei-dati-mancanti}{%
\subsection{Trattamento dei dati mancanti}\label{trattamento-dei-dati-mancanti}}

Se una variabile contiene valori mancanti, \texttt{R} non è in grado di applicare ad essa alcune Funzioni, come ad esempio la media. Per questa ragione, la gran parte delle funzioni di \texttt{R} prevedono modi specifici per trattare i valori mancanti.

Ci sono diversi tipi di dati ``mancanti'' in \texttt{R};

\begin{itemize}
\tightlist
\item
  \texttt{NA} - generico dato mancante;
\item
  \texttt{NaN} - il codice \texttt{NaN} (\emph{Not a Number}) indica i valori numerici impossibili, quali ad esempio un valore 0/0;
\item
  \texttt{Inf} e \texttt{-Inf} - Infinity, si verifca, ad esempio, quando si divide un numero per 0.
\end{itemize}

La funzione \texttt{is.na()} ritorna un output che indica con TRUE le celle che contengono NA o NaN.

Si noti che

\begin{itemize}
\tightlist
\item
  se \texttt{is.na(x)} è TRUE, allora \texttt{!is.na(x)} è FALSE;
\item
  \texttt{all(!is.na(x))} ritorna TRUE se tutti i valori \texttt{x} sono NOT NA;
\item
  \texttt{any(is.na(x))} risponde alla domanda: c'è qualche valore NA (almeno uno) in \texttt{x}?;
\item
  \texttt{complete.cases(x)} ritorna TRUE se ciascun elemento di \texttt{x} è is NOT NA; ritorna FALSE se almeno un elemento di \texttt{x} è NA;
\end{itemize}

Le funzioni \texttt{R} \texttt{is.nan()} e \texttt{is.infinite()} si applicano ai tipi di dati \texttt{NaN} e \texttt{Inf}.

Per esempio, consideriamo il seguente data.frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d }\OtherTok{\textless{}{-}} \FunctionTok{tibble}\NormalTok{(}
  \AttributeTok{w =} \FunctionTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\DecValTok{3}\NormalTok{, }\ConstantTok{NA}\NormalTok{),}
  \AttributeTok{x =} \DecValTok{1}\SpecialCharTok{:}\DecValTok{5}\NormalTok{,}
  \AttributeTok{y =} \DecValTok{1}\NormalTok{,}
  \AttributeTok{z =}\NormalTok{ x}\SpecialCharTok{\^{}}\DecValTok{2} \SpecialCharTok{+}\NormalTok{ y,}
  \AttributeTok{q =} \FunctionTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\ConstantTok{NA}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\NormalTok{)}
\NormalTok{d}
\CommentTok{\#\textgreater{} \# A tibble: 5 x 5}
\CommentTok{\#\textgreater{}       w     x     y     z     q}
\CommentTok{\#\textgreater{}   \textless{}dbl\textgreater{} \textless{}int\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1     1     1     1     2     3}
\CommentTok{\#\textgreater{} 2     2     2     1     5    NA}
\CommentTok{\#\textgreater{} 3    NA     3     1    10     5}
\CommentTok{\#\textgreater{} 4     3     4     1    17     1}
\CommentTok{\#\textgreater{} 5    NA     5     1    26     4}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{is.na}\NormalTok{(d}\SpecialCharTok{$}\NormalTok{w)}
\CommentTok{\#\textgreater{} [1] FALSE FALSE  TRUE FALSE  TRUE}
\FunctionTok{is.na}\NormalTok{(d}\SpecialCharTok{$}\NormalTok{x)}
\CommentTok{\#\textgreater{} [1] FALSE FALSE FALSE FALSE FALSE}
\end{Highlighting}
\end{Shaded}

Per creare un nuovo Dataframe senza valori mancanti:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_clean }\OtherTok{\textless{}{-}}\NormalTok{ d[}\FunctionTok{complete.cases}\NormalTok{(d), ]}
\NormalTok{d\_clean}
\CommentTok{\#\textgreater{} \# A tibble: 2 x 5}
\CommentTok{\#\textgreater{}       w     x     y     z     q}
\CommentTok{\#\textgreater{}   \textless{}dbl\textgreater{} \textless{}int\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1     1     1     1     2     3}
\CommentTok{\#\textgreater{} 2     3     4     1    17     1}
\end{Highlighting}
\end{Shaded}

Oppure, se vogliamo eliminare le righe con NA solo in una variabile:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d1 }\OtherTok{\textless{}{-}}\NormalTok{ d[}\SpecialCharTok{!}\FunctionTok{is.na}\NormalTok{(d}\SpecialCharTok{$}\NormalTok{q), ]}
\NormalTok{d1}
\CommentTok{\#\textgreater{} \# A tibble: 4 x 5}
\CommentTok{\#\textgreater{}       w     x     y     z     q}
\CommentTok{\#\textgreater{}   \textless{}dbl\textgreater{} \textless{}int\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1     1     1     1     2     3}
\CommentTok{\#\textgreater{} 2    NA     3     1    10     5}
\CommentTok{\#\textgreater{} 3     3     4     1    17     1}
\CommentTok{\#\textgreater{} 4    NA     5     1    26     4}
\end{Highlighting}
\end{Shaded}

Se vogliamo esaminare le righe con i dati mancanti in qualunque colonna:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d\_na }\OtherTok{\textless{}{-}}\NormalTok{ d[}\SpecialCharTok{!}\FunctionTok{complete.cases}\NormalTok{(d), ]}
\NormalTok{d\_na}
\CommentTok{\#\textgreater{} \# A tibble: 3 x 5}
\CommentTok{\#\textgreater{}       w     x     y     z     q}
\CommentTok{\#\textgreater{}   \textless{}dbl\textgreater{} \textless{}int\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{} \textless{}dbl\textgreater{}}
\CommentTok{\#\textgreater{} 1     2     2     1     5    NA}
\CommentTok{\#\textgreater{} 2    NA     3     1    10     5}
\CommentTok{\#\textgreater{} 3    NA     5     1    26     4}
\end{Highlighting}
\end{Shaded}

Spesso i valori mancanti vengono sostiuti con valori ``ragionevoli'', come ad esempio la media dei valori in quella colonna del Dataframe. Oppure, vengono considerati come ``ragionevoli'' i valori che vengono predetti conoscendo le altre variabili del Dataframe. Questa procedura si chiama \emph{imputazione multipla}. Questo è però un argomento avanzato che non verrà trattato in questo insegnamento. La cosa più semplice da fare, in presenza di dati mancanti, è semplicemente quella di escludere tutte le righe nelle quali ci sono degli NAs.

  \bibliography{refs.bib,book.bib,packages.bib}

\end{document}
